{
    "number": 185,
    "label": 2,
    "source": "NIST",
    "subject": "Recommendation for Block Cipher Modes of Operation: Methods for Format-Preserving Encryption",
    "document(english)": "Draft SP 800-38G Rev. 1, Recommendation for Block Cipher Modes of Operation: Methods for Format-Preserving Encryption  Draft NIST Special Publication 800-38G 1  Revision 1 2  Recommendation for Block Cipher 3  Modes of Operation 4  Methods for Format-Preserving Encryption 5  6  7  Morris Dworkin 8  9  10  11  12  13  14  15  This publication is available free of charge from: 16  https://doi.org/10.6028/NIST.SP.800-38Gr1-draft 17  18  19  20  C  O  M  P  U  T  E  R  S  E  C  U  R  I  T  Y 21  22  23  Draft NIST Special Publication 800-38G 24  Revision 1 25  26  Recommendation for Block Cipher 27  Modes of Operation  28  Methods for Format-Preserving Encryption 29  30  31  Morris Dworkin 32  Computer Security Division 33  Information Technology Laboratory 34  35  36  37  38  39  This publication is available free of charge from: 40  https://doi.org/10.6028/NIST.SP.800-38Gr1-draft 41  42  43  February 2019 44  45  46  47  48  49  U.S. Department of Commerce 50  Wilbur L. Ross, Jr., Secretary 51  52  National Institute of Standards and Technology  53  Walter Copan, NIST Director and Under Secretary of Commerce for Standards and Technology  54  Authority 55  This publication has been developed by NIST in accordance with its statutory responsibilities under the 56  Federal Information Security Modernization Act (FISMA) of 2014, 44 U.S.C. § 3551 et seq., Public Law 57  (P.L.) 113-283. NIST is responsible for developing information security standards and guidelines, including 58  minimum requirements for federal information systems, but such standards and guidelines shall not apply 59  to national security systems without the express approval of appropriate federal officials exercising policy 60  authority over such systems. This guideline is consistent with the requirements of the Office of Management 61  and Budget (OMB) Circular A-130. 62  Nothing in this publication should be taken to contradict the standards and guidelines made mandatory and 63  binding on federal agencies by the Secretary of Commerce under statutory authority. Nor should these 64  guidelines be interpreted as altering or superseding the existing authorities of the Secretary of Commerce, 65  Director of the OMB, or any other federal official. This publication may be used by nongovernmental 66  organizations on a voluntary basis and is not subject to copyright in the United States. Attribution would, 67  however, be appreciated by NIST. 68  69  70  71  72  National Institute of Standards and Technology Special Publication 800-38G Revision 1  Natl. Inst. Stand. Technol. Spec. Publ. 800-38G, 31 pages (February 2019)  CODEN: NSPUE2  This publication is available free of charge from:  https://doi.org/10.6028/NIST.SP.800-38Gr1-draft 73  Certain commercial entities, equipment, or materials may be identified in this document in order to describe an 74  experimental procedure or concept adequately. Such identification is not intended to imply recommendation or 75  endorsement by NIST, nor is it intended to imply that the entities, materials, or equipment are necessarily the best 76  available for the purpose. 77  There may be references in this publication to other publications currently under development by NIST in accordance 78  with its assigned statutory responsibilities. The information in this publication, including concepts and methodologies, 79  may be used by federal agencies even before the completion of such companion publications. Thus, until each 80  publication is completed, current requirements, guidelines, and procedures, where they exist, remain operative. For 81  planning and transition purposes, federal agencies may wish to closely follow the development of these new 82  publications by NIST 83  Organizations are encouraged to review all draft publications during public comment periods and provide feedback to 84  NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at 85  https://csrc.nist.gov/publications.86  Public comment period: February 28, 2019 through April 15, 2019 87  National Institute of Standards and Technology 88  Attn: Computer Security Division, Information Technology Laboratory 89  100 Bureau Drive (Mail Stop 8930) Gaithersburg, MD 20899-8930 90  Email: encryptionmodes@nist.gov  91  92  All comments are subject to release under the Freedom of Information Act (FOIA).93  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  i  Reports on Computer Systems Technology 94  95  The Information Technology Laboratory (ITL) at the National Institute of Standards and 96  Technology (NIST) promotes the U.S. economy and public welfare by providing technical 97  leadership for the Nation’s measurement and standards infrastructure. ITL develops tests, test 98  methods, reference data, proof of concept implementations, and technical analyses to advance the 99  development and productive use of information technology. ITL’s responsibilities include the 100  development of management, administrative, technical, and physical standards and guidelines for 101  the cost-effective security and privacy of other than national security-related information in federal 102  information systems. The Special Publication 800-series reports on ITL’s research, guidelines, and 103  outreach efforts in information system security, and its collaborative activities with industry, 104  government, and academic organizations. 105  Abstract 106  This Recommendation specifies two methods, called FF1 and FF3-1, for format-preserving 107  encryption. Both of these methods are modes of operation for an underlying, approved symmetric-108  key block cipher algorithm. Compared to the original version of this publication, the tweak size 109  for FF3-1 is smaller than the tweak size for FF3; also, for both FF1 and FF3-1, larger domains are 110  required, rather than merely recommended. 111  Keywords  112  Block cipher; confidentiality; encryption; FF1; FF3; FF3-1; format-preserving encryption; 113  information security; mode of operation.  114  115  116  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  ii  Acknowledgements 117  The author gratefully acknowledges the designers of the two algorithms that are specified in this 118  publication: 1) Mihir Bellare, Phil Rogaway, and Terence Spies; and 2) Eric Brier, Thomas Peyrin, 119  and Jacques Stern. 120  Serge Vaudenay and Betül Durak kindly gave NIST early notification of their analysis of the FF3 121  method in [7], which prompted the revision of the method in this version of the publication.  122  Similarly, Mihir Bellare, Viet Tung Hoang, Stefano Tessaro gave NIST early notification of their 123  analysis of the FPE modes in [1], which was subsequently improved by Hoang and Tessaro in their 124  paper with Ni Trieu [8].  These papers motivated the larger lower limit on the number of inputs 125  for both FF1 and FF3-1, which previously had been recommended but not required. 126  The author also wishes to thank his colleagues who reviewed drafts of this publication and 127  contributed to its development, especially Elaine Barker, Nicky Mouha, Lily Chen, John Kelsey, 128  Meltem Sonmez Turan, Kerry McKay, Allen Roginsky, Larry Bassham, Ray Perlner, Rene 129  Peralta, Jim Foti, Sara Kerman, Andy Regenscheid, Bill Burr, and Tim Polk. 130  The author also acknowledges the comments from the public and private sectors to improve the 131  quality of this publication. 132  Conformance Testing 133  Conformance testing for implementations of the functions that are specified in this publication will 134  be conducted within the framework of the Cryptographic Algorithm Validation Program (CAVP) 135  and the Cryptographic Module Validation Program (CMVP). The requirements on these 136  implementations are indicated by the word “shall.” Some of these requirements may be out-of-137  scope for CAVP or CMVP validation testing, and thus are the responsibility of entities using, 138  implementing, installing, or configuring applications that incorporate this Recommendation.  139  140  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  iii  Call for Patent Claims 141  142  This public review includes a call for information on essential patent claims (claims whose use 143  would be required for compliance with the guidance or requirements in this Information 144  Technology Laboratory (ITL) draft publication). Such guidance and/or requirements may be 145  directly stated in this ITL Publication or by reference to another publication. This call also includes 146  disclosure, where known, of the existence of pending U.S. or foreign patent applications relating 147  to this ITL draft publication and of any relevant unexpired U.S. or foreign patents. 148  149  ITL may require from the patent holder, or a party authorized to make assurances on its behalf, in 150  written or electronic form, either: 151  152  a) assurance in the form of a general disclaimer to the effect that such party does not hold and does 153  not currently intend holding any essential patent claim(s); or 154  155  b) assurance that a license to such essential patent claim(s) will be made available to applicants 156  desiring to utilize the license for the purpose of complying with the guidance or requirements in 157  this ITL draft publication either: 158  159  i) under reasonable terms and conditions that are demonstrably free of any unfair 160  discrimination; or 161  162  ii) without compensation and under reasonable terms and conditions that are demonstrably 163  free of any unfair discrimination. 164  165  Such assurance shall indicate that the patent holder (or third party authorized to make assurances 166  on its behalf) will include in any documents transferring ownership of patents subject to the 167  assurance, provisions sufficient to ensure that the commitments in the assurance are binding on 168  the transferee, and that the transferee will similarly include appropriate provisions in the event of 169  future transfers with the goal of binding each successor-in-interest. 170  171  The assurance shall also indicate that it is intended to be binding on successors-in-interest 172  regardless of whether such provisions are included in the relevant transfer documents. 173  174  Such statements should be addressed to: EncryptionModes@nist.gov.  175  176  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  iv  Table of Contents 177  178  1  Purpose .................................................................................................................... 1 179  2  Introduction ............................................................................................................. 1 180  3  Definitions and Notation ......................................................................................... 2 181  3.1  Definitions ........................................................................................................ 2 182  3.2  Acronyms ......................................................................................................... 4 183  3.3  Operations and Functions ................................................................................ 5 184  4  Preliminaries ............................................................................................................ 6 185  4.1  Representation of Character Strings ................................................................ 6 186  4.2  Underlying Block Cipher and Key .................................................................... 7 187  4.3  Encryption and Decryption Functions .............................................................. 8 188  4.4  Feistel Structure ............................................................................................... 8 189  4.5  Component Functions .................................................................................... 10 190  5  Mode Specifications .............................................................................................. 12 191  5.1  FF1 ................................................................................................................. 13 192  5.2  FF3-1 ............................................................................................................. 15 193  6  Conformance ......................................................................................................... 17 194  Appendix A: Parameter Choices and Security .......................................................... 18 195  Appendix B: Security Goal .......................................................................................... 19 196  Appendix C: Tweaks .................................................................................................... 20 197  Appendix D: Examples ................................................................................................. 21 198  Appendix E: References .............................................................................................. 22 199  Appendix F: Revision History ..................................................................................... 24 200  201  List of Figures 202  203  Figure 1: Feistel Structure .................................................................................................... 9 204  205  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  1  1 Purpose 206  This publication is a revision of the seventh part in a series of Recommendations regarding the 207  modes of operation of block cipher algorithms. The purpose of this part is to provide two approved 208  methods for format-preserving encryption (FPE).  209  Since the original publication of these FPE modes in March of 2016, researchers identified 210  vulnerabilities in [8], building on the work in [1], and in [7]. The present revision includes sets of 211  technical revisions to mitigate the vulnerabilities, as summarized in Appendix F.  212  2 Introduction 213  A block cipher mode of operation—or simply, mode—is an algorithm for the cryptographic 214  transformation of data that is based on a block cipher. The previously approved modes for 215  encryption are transformations on binary data, i.e., the inputs and outputs of the modes are bit 216  strings—sequences of ones and zeros. For sequences of non-binary symbols, however, there is no 217  natural and general way for the previously approved modes to produce encrypted data that has the 218  same format. For example, a Social Security Number (SSN) consists of nine decimal digits, so it 219  is an integer that is less than one billion. This integer can be converted to a bit string as input to a 220  previously approved mode, but when the output bit string is converted back to an integer, it may 221  be greater than one billion, which would be too long for an SSN.  222  FPE is designed for data that is not necessarily binary. In particular, given any finite set of symbols, 223  like the decimal numerals, a method for FPE transforms data that is formatted as a sequence of the 224  symbols in such a way that the encrypted form of the data has the same format, including the 225  length, as the original data. Thus, an FPE-encrypted SSN would be a sequence of nine decimal 226  digits. 227  FPE facilitates the targeting of encryption to sensitive information, as well as the retrofitting of 228  encryption technology to legacy applications, where a conventional encryption mode might not be 229  feasible. For example, database applications may not support changes to the length or format of 230  data fields. FPE has emerged as a useful cryptographic tool, whose applications include financial-231  information security, data sanitization, 1  and the transparent encryption of fields in legacy 232  databases. 233  The two FPE modes specified in this publication are called FF1 and FF3-1. FF3-1 is a revision of 234  the FF3 mode that was specified in the original version of this publication; the revision of FF3, as 235  well as a modified requirement for both FF1 and FF3-1, are described in Appendix F. The 236  acronyms for the modes indicate that they are format-preserving, Feistel-based encryption modes. 237  FF1 was submitted to NIST under the name FFX[Radix] in [3]. FF3 is a component of the FPE 238  method that was submitted to NIST under the name BPS in [4]. In particular, FF3 is essentially 239  equivalent to the BPS-BC component of BPS, instantiated with a 128-bit block cipher. The full 240  BPS mode—in particular, its chaining mechanism for longer input strings—is not approved in this 241  publication. 242  1 The sanitization of personally identifiable information in a database—whether by FPE or other methods—does not  necessarily provide strong assurance that individuals cannot be re-identified; for example, see [5].  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  2  Each of these FPE modes fits within a larger framework, called FFX, for constructing FPE 243  mechanisms; FFX was submitted to NIST in [2]. The “X” indicates the flexibility to instantiate the 244  framework with different parameter sets, as well as FFX’s evolution from its precursor, the Feistel 245  Finite Set Encryption Mode.  246  The FFX framework itself is not specified in this publication; in fact, FF1 and FF3-1 are not 247  presented explicitly as instantiations of FFX parameter sets, but rather as separate algorithms, in 248  order to simplify the individual specifications. 249  FF1 and FF3-1 each employ the Feistel structure—see Sec. 4.4—which also underlies the Triple 250  Data Encryption Algorithm (TDEA) [15]. At the core of FF1 and FF3-1 are somewhat different 251  Feistel round functions that are derived from an approved block cipher with 128-bit blocks, i.e., 252  the Advanced Encryption Standard (AES) algorithm [12]. 253  In addition to the formatted data for which the modes provide confidentiality, each mode also takes 254  an additional input called the “tweak,” which is not necessarily secret. The tweak can be regarded 255  as a changeable part of the key, because together they determine the encryption and decryption 256  functions. Tweaks that vary can be especially important for implementations of FPE modes, 257  because the number of possible values for the confidential data is often relatively small, as 258  discussed in Appendix A and Appendix C. 259  FF1 and FF3-1 offer somewhat different performance advantages. FF1 supports a greater range of 260  lengths for the protected, formatted data, as well as flexibility in the length of the tweak. FF3-1 261  achieves greater throughput, mainly because it has eight rounds, compared to ten for FF1.  262  3 Definitions and Notation 263  3.1 Definitions 264  alphabet A finite set of two or more symbols.  approved  FIPS-approved or NIST-recommended: an algorithm or technique that is either  1) specified in a FIPS or a NIST Recommendation, or 2) adopted in a Federal  Information Processing Standard (FIPS) or a NIST Recommendation.  base The number of characters in a given alphabet. The base is denoted by radix.  bit A binary digit: 0 or 1.  bit string  A finite, ordered sequence of bits.  block  For a given block cipher, a bit string whose length is the block size of the block  cipher.  block cipher A parameterized family of permutations on bit strings of a fixed length; the  parameter that determines the permutation is a bit string called the key.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  3  block cipher  mode of  operation  An algorithm for the cryptographic transformation of data that is based on a  block cipher.  block size For a given block cipher and key, the fixed length of the input (or output) bit  strings.  block string A bit string whose length is a multiple of a given block size, so that it can be  represented as the concatenation of a finite sequence of blocks.  byte A string of eight bits.  byte string A bit string whose length is a multiple of eight bits, so that it can be represented  as the concatenation of a finite sequence of bytes.  character A symbol in a given alphabet.  character string A finite, ordered sequence of characters from a given alphabet.  ciphertext In this publication, the numeral string that is the encrypted form of a plaintext  numeral string.  decryption  function  For a given block cipher and key, the function of an FPE mode that takes a  ciphertext numeral string and a tweak as input and returns the corresponding  plaintext numeral string as output.  designated  cipher function  For a given block cipher and key, the choice of either the forward  transformation or the inverse transformation.  encryption  function  For a given block cipher and key, the function of an FPE mode that takes a  plaintext numeral string and a tweak as input and returns a ciphertext numeral  string as output.  exclusive-OR  (XOR)  The bitwise addition, modulo 2, of two bit strings of equal length.  Feistel structure  A framework for constructing an encryption mode. The framework consists of  several iterations, called rounds, in which a keyed function, called the round  function, is applied to one part of the data in order to modify the other part of  the data; the roles of the two parts are swapped for the next round.  forward  transformation  For a given block cipher, the permutation of blocks that is determined by the  choice of a key.  inverse  transformation For a given block cipher, the inverse of the forward transformation .  key For a given block cipher, the secret bit string that parameterizes the  permutation.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  4  3.2 Acronyms 265  AES Advanced Encryption Standard.  CAVP Cryptographic Algorithm Validation Program.  CCN credit card number.  CMVP Cryptographic Module Validation Program.  FIPS Federal Information Processing Standard.  FISMA Federal Information Security Management Act.  FPE format-preserving encryption.  IETF Internet Engineering Task Force.  ITL Information Technology Laboratory.  NIST National Institute of Standards and Technology.  PRF pseudorandom function.  PRP pseudorandom permutation.  RFC Request for Comment.  SSN Social Security number.  266  mode See block cipher mode of operation.  numeral For a given base, a nonnegative integer less than the base.  numeral string For a given base, a finite, ordered sequence of numerals for the base.  plaintext In this publication, a numeral string whose confidentiality is protected by an  FPE mode.  prerequisite A required input to an algorithm that has been established prior to the  invocation of the algorithm.  shall Is required to. Requirements apply to conforming implementations.  should Is recommended to.  tweak The input parameter to the encryption and decryption functions whose  confidentiality is not necessarily protected by the mode.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  5  3.3 Operations and Functions 267  BYTELEN(X)  The number of bytes in a byte string, X, which may be represented as a bit  string.  For example, BYTELEN(1011100110101100) = 2.  CIPHK (X) The output of the designated cipher function of the block cipher under the  key K applied to the block X.  LEN(X) The number of numerals/bits in a numeral/bit string X.  For example,  LEN(010) = 3.  LOG(x) The base 2 logarithm of the real number x > 0. For example, LOG(64) = 6  and LOG(10) ≈ 3.32.  NUM(X)  The integer that a bit string X represents when the bits are valued in  decreasing order of significance. For example, NUM(10000000) = 128. An  algorithm for computing NUM(X) is given in Sec. 4.5.  NUMradix (X)  The number that the numeral string X represents in base radix when the  numerals are valued in decreasing order of significance. For example,  NUM5 (00011010) = 755. An algorithm for computing NUM radix (X) is given  in Sec. 4.5.  PRF(X) The output of the function PRF applied to the block X; PRF is defined in terms  of a given designated cipher function.  REV(X) Given a numeral string, X, the numeral string that consists of the numerals  of X in reverse order. For example, in base ten, REV(13579) = 97531.  REVB(X) Given a byte string, X, the byte string that consists of the bytes of X in  reverse order. For example, REVB([1]1  || [2]1  || [3]1) = [3]1  || [2]1  || [1]1.  STRm radix (x)  Given a nonnegative integer x less than radixm, the representation of x as a  string of m numerals in base radix, in decreasing order of significance. For  example, STR 4  12  (559) is the string of four numerals in base 12 that represents  559, namely, 0 3 10 7. An algorithm for computing STR mradix (x) is given in  Sec. 4.5.  ⌊x⌋ The floor function: given a real number x, the greatest integer that does not  exceed x.  For example, ⌊2.1⌋ = 2, and ⌊4⌋ = 4.  éxù The ceiling function:  given a real number x, the least integer that is not less  than x.  For example, é2.1ù = 3, and é4ù = 4.  [x]s Given a nonnegative integer x less than 256 s, the representation of x as a  string of s bytes. For example, [5]1 = 00000000 00000101.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  6  4 Preliminaries 268  4.1 Representation of Character Strings 269  The data inputs and outputs for FF1 and FF3-1 are sequences of numbers that can represent both 270  numeric and non-numeric data, as discussed below. 271  A finite set of two or more symbols is called an alphabet. The symbols in an alphabet are called 272  the characters of the alphabet. The number of characters in an alphabet is called the base, denoted 273  by radix; thus, radix ≥ 2. 274  A character string is a finite sequence of characters from an alphabet; individual characters may 275  repeat in the string. In this publication, character strings (and bit strings) are presented in the 276  Courier New font.  277  Thus, for the alphabet of lower-case English letters, 278  {a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z}, 279  hello and cannot are character strings, but Hello and can’t are not, because the symbols 280  “H” and “ ′ ” are not in the alphabet. 281  SSNs or Credit Card Numbers (CCNs) can be regarded as character strings in the alphabet of base 282  ten numerals, namely, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. The notion of numerals is generalized to any 283  given base as follows: the set of base radix numerals is 284  {0, 1, …, radix-1}. 285  [i .. j] The set of integers between two integers i and j, including i and j. For  example, [2 .. 5] = {2, 3, 4, 5}.  x mod m The nonnegative remainder of the integer x modulo the positive integer m,  i.e., x – m⌊x/m⌋. For example, 13 mod 7 = 6, and -3 mod 7 = 4.  X [i] Given a numeral/bit string X and an index i such that 1 ≤ i ≤ LEN(X), the i th  numeral/bit of X. For example, in base ten, if X = 798137, then X [2] = 9.  X [i .. j] The substring of the string X from X [i] to X [j], including X [i] and X [j].  For  example, in base ten, if X = 798137, then X [3 .. 5] = 813.  X ⊕ Y  The bitwise exclusive-OR of bit strings X and Y whose bit lengths are equal.  For example, 10011 ⊕ 10101 = 00110.  X || Y The concatenation of numeral strings X and Y.  For example,  001 || 1011 = 0011011, and 3 1 || 31 8 10 = 3 1 31 8 10.  0s  The bit string that consists of s consecutive ‘0’ bits. For example,  08 = 00000000.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  7  The data inputs and outputs to the FF1 and FF3-1 encryption and decryption functions must be 286  finite sequences of numerals, i.e., numeral strings. If the data to be encrypted is formatted in an 287  alphabet that is not already the set of base radix numerals, then each character must be represented 288  by a distinct numeral in order to apply FF1 or FF3-1.  289  For example, the natural representation of lower-case English letters with base 26 numerals is  290  a→0, b→1, c→2, … x→23, y→24, z→25. 291  The character string hello would then be represented by the numeral string 7 4 11 11 14. Other 292  representations are possible.  293  The choice and implementation of a one-to-one correspondence between a given alphabet and the 294  set of base radix numerals that represents the alphabet is outside the scope of this publication. 295  In this publication, individual numerals are themselves represented in base ten. In order to display 296  numeral sequences unambiguously when the base is greater than ten, a delimiter between the 297  numerals is required, such as a space (as in the base 26 example above) or a comma. 298  FF1 and FF3-1 use different conventions for interpreting numeral strings as numbers. For FF1, 299  numbers are represented by strings of numerals with decreasing order of significance; for FF3-1, 300  numbers are represented by strings of numerals in the reverse order, i.e., with increasing order of 301  significance. For example, “0025” is a string of decimal digits that represents the number twenty-302  five for FF1 and the number five thousand two hundred for FF3-1. Algorithms for the functions 303  that convert numeral strings to numbers and vice versa are given in Sec. 4.5.  304  4.2 Underlying Block Cipher and Key 305  The encryption and decryption functions of FF1 and FF3-1 feature a block cipher as the main 306  component; thus, each of these FPE mechanisms is a mode of operation (mode, for short) of the 307  block cipher.  308  For any given key, K, the underlying block cipher of the mode is a permutation, i.e., an invertible 309  transformation on bit strings of a fixed length; the fixed-length bit strings are called blocks, and 310  the length of a block is called the block size. For an FPE mode, as part of the choice of the 311  underlying block cipher with the key, either the forward transformation or the inverse 312  transformation2 is specified as the designated cipher function, denoted by CIPHK. The inverse of 313  CIPHK is not needed for the modes that are specified in this publication.  314  For both modes, the underlying block cipher shall be approved, and the block size shall be 128 315  bits. Currently, the AES block cipher [12], with key lengths of 128, 192, or 256 bits, is the only 316  block cipher that fits this profile.  317  The choice of the key length affects the security of the FPE modes, e.g., against brute-force search, 318  and also affects the details of the implementation of the AES algorithm. Otherwise, the key length 319  does not affect the implementation of FF1 and FF3-1, and the choice of the key length is not 320  2 The forward transformation and the inverse transformations are sometimes referred to as the “encrypt” and “decrypt”  functions, respectively, of the block cipher; however, in this publication, “encrypt” and “decrypt” are reserved for  functions of the FPE modes.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  8  explicitly indicated in their specifications. Methods for generating cryptographic keys are 321  discussed in [16]; the goal is to select the keys uniformly at random, i.e., for each possible key to 322  occur with equal probability.  323  The key shall be kept secret, i.e., disclosed only to parties that are authorized to know the protected 324  information. Compliance with this requirement is the responsibility of the entities using, 325  implementing, installing, or configuring applications that incorporate the functions that are 326  specified in this publication. The management of cryptographic keys is outside the scope of this 327  publication. 328  4.3 Encryption and Decryption Functions 329  For a given key, denoted by K, for the designated block cipher, FF1 and FF3-1 each consist of two 330  related functions: encryption and decryption. The inputs to the encryption function are a numeral 331  string called the plaintext, denoted by X, and a byte string, called the tweak, denoted by T; the 332  function returns a numeral string called the ciphertext, denoted by Y, with the same length as X. 333  Similarly, the inputs to the decryption function are a numeral string X and a tweak T; the output is 334  a numeral string Y of the same length as X.  335  For FF1, the encryption function is denoted by FF1.Encrypt(K, T, X), and the decryption function 336  is denoted by FF1.Decrypt(K, T, X), with analogous notation for FF3-1. 337  For a given tweak, the decryption function is the inverse of the encryption function, so that  338  FF1.Decrypt(K, T, FF1.Encrypt(K, T, X)) = X, 339  FF3-1.Decrypt(K, T, FF3-1.Encrypt(K, T, X)) = X. 340  341  The tweak does not need to be kept secret; often, it is some readily available data that is associated 342  with the plaintext. Although implementations may fix the value of the tweak, variable tweaks 343  should be used as a security enhancement; see Appendix C. In FF1 and FF3-1, tweaks are byte 344  strings. The specifications in Sec. 5 include the lengths that can be supported for the tweak, as well 345  as for the plaintext/ciphertext. 346  The key, K, is indicated in the above notation as an input for the encryption and decryption 347  functions; however, in the specifications in this publication, the key is listed as a prerequisite, i.e., 348  an input that is usually established prior to the invocation of the function. 3  Several other 349  prerequisites are omitted from the above notation, such as the underlying block cipher, the 350  designation of CIPHK, and the base for the numeral strings. 351  4.4 Feistel Structure 352  FFX schemes, including FF1 and FF3-1, are based on the Feistel structure. The Feistel structure 353  consists of several iterations, called rounds, of a reversible transformation. The transformation 354  consists of three steps: 1) the data is split into two parts; 2) a keyed function, called the round 355  function, is applied to one part of the data in order to modify the other part of the data; and 3) the 356  roles of the two parts are swapped for the next round. The structure is illustrated in Figure 1 below, 357  3 The distinction does not affect the execution of the function: all information is required, independent of when they  were established or provided to the implementation.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  9  for both encryption and decryption. Four rounds are shown in Figure 1, but ten rounds are actually 358  specified for FF1, and eight rounds for FF3-1. 359  360  361  Figure 1: Feistel Structure  362  For the encryption function example in Figure 1, the rounds are indexed from 0 to 3. The input 363  data (and output data) for each round are two strings of characters—which will be numerals for 364  FF1 and FF3-1. The lengths of the two strings are denoted by u and v, and the total number of 365  characters is denoted by n, so that u + v = n. During Round i, the round function, denoted by FK, is 366  applied to one of the input strings, denoted by Bi, with the length n, the tweak T, and the round 367  number i as additional inputs. (In Figure 1, this triple (n, T, i) of additional inputs is indicated 368  within the dotted rectangles, with the appropriate values for i). The result is used to modify the 369  other string, denoted by Ai, via modular addition4, indicated by +, on the numbers that the strings 370  4 For some applications of the Feistel structure—but not FF1 and FF3-1—the “+” operation may be a different  reversible operation on strings that preserves their length; for example, the FFX specification in [2] supports an option  for character-wise addition.  u!characters! v!characters!  B1!←!C0! A1!←!B0!  FK!  +! n,!T,!0!  A0! B0!  FK!  +!n,!T,!1!  A2!←!B1! B2!←!C1!  B3!←!C2! A3!←!B2!  FK!  +! n,!T,!2!  FK!  +!n,!T,!3!  A4!←!B3! B4!←!C3!  u!characters! v!characters!  B1!←!A2! A1!  A0! B0!←!A1!  A2!! B2!←!A3!  B3!←!A4! A3!!  A4!! B4!  FK!  _! n,!T,!2!  FK!  _! n,!T,!0!  FK!  _!n,!T,!3!  FK!  _!n,!T,!1!  Encryption! Decryption!  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  10  represent5. The string that represents the resulting number is named with a temporary variable, Ci. 371  The names of the two parts are swapped for the next round, so that the modified Ai, i.e., Ci, becomes 372  Bi+1, and Bi becomes Ai+1.  373  The rectangles containing the two parts of the data have different sizes in order to illustrate that u 374  cannot equal v if n is odd. In such cases, the round function is constructed so that the lengths of its 375  input and output strings depend on whether the round number index, i, is even or odd.  376  The Feistel structure for decryption is almost identical to the Feistel structure for encryption. There 377  are three differences: 1) the order of the round indices is reversed; 2) the roles of the two parts of 378  the data in the round function are swapped as follows: along with n, T, and i, the input to FK is Ai+1 379  (not Bi), and the output is combined with Bi+1 (not Ai) to produce Ai (not Bi+1); and 3) modular 380  addition (of the output of FK to Ai) is replaced by modular subtraction (of the output of FK from 381  Bi +1).  382  4.5 Component Functions 383  This section gives algorithms for the component functions that are called in the specifications of 384  FF1 and FF3-1. The conversion functions NUMradix(X), NUM(X), and STRm  radix(x) are defined in 385  Sec. 3.3, including examples, and they are specified in Algorithms 1-3 below. These functions 386  support the ordering convention for the numeral/bit strings in FF1, namely, that the first (i.e., left-387  most) numeral/bit of the string is the most-significant numeral/bit 388  In FF3-1, the numeral strings follow the opposite ordering convention, as do the byte strings for 389  the block cipher. In order to adapt NUMradix(X), STRm  radix (x), and CIPHK (X) for the FF3-1 390  specifications, the functions REV(X) and REVB(X) are defined in Sec. 3.3 and specified in 391  Algorithms 4 and 5. 392  The PRF(X) function, specified in Algorithm 6, essentially invokes the Cipher Block Chaining 393  encryption mode [14] on the input bit string and returns the final block of the ciphertext; this 394  function is the pseudorandom core of the Feistel round function for FF1.Encrypt and FF1.Decrypt.  395  In order to simplify the specifications of NUM(X), REVB(X), and PRF(X), the byte or block strings 396  in Algorithms 2, 5, and 6 are represented as bit strings.  397  Algorithm 1: NUMradix (X)  398  399  Prerequisite: 400  Base, radix. 401  402  Input: 403  Numeral string, X. 404  405  Output: 406  Number, x. 407  408  409  5 The ordering convention for interpreting strings as numbers is different for FF3-1 than for FF1.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  11  Steps: 410  1. Let x = 0. 411  2. For i from 1 to LEN(X), let x = x × radix + X [i]. 412  3. Return x. 413  414  Algorithm 2: NUM(X)  415  416  Input: 417  Byte string, X, represented in bits. 418  419  Output: 420  Integer, x. 421  422  Steps: 423  1. Let x = 0. 424  2. For i from 1 to LEN(X), let x = 2 x + X [i]. 425  3. Return x. 426  427  Algorithm 3: STRm radix (x) 428  429  Prerequisites: 430  Base, radix; 431  String length, m. 432  433  Input: 434  Integer, x, such that 0 ≤ x < radixm. 435  436  Output: 437  Numeral string, X. 438  439  Steps: 440  1. For i from 1 to m: 441  i. X [m + 1– i] = x mod radix;  442  ii. x = ëx/radixû. 443  2.  Return X. 444  Algorithm 4: REV(X )  445  446  Input: 447  Numeral string, X. 448  449  Output: 450  Numeral string, Y. 451  452  Steps: 453  1.  For i from 1 to LEN(X), let Y [i] = X [LEN(X) + 1 – i]. 454  2.  Return Y [1 .. LEN(X)].  455  456  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  12  Algorithm 5: REVB(X)  457  458  Input: 459  Byte string, X, represented in bits. 460  461  Output: 462  Byte string, Y, represented in bits. 463  464  Steps: 465  1.  For i from 0 to BYTELEN(X) – 1 and j from 1 to 8, let Y [8i + j] = X [8 × (BYTELEN(X) – 1– i) + j]. 466  2.  Return Y [1 .. 8 × BYTELEN(X)].  467  468  Algorithm 6: PRF(X)  469  470  Prerequisites: 471  Designated cipher function, CIPH, of an approved 128-bit block cipher; 472  Key, K, for the block cipher. 473  474  Input:  475  Block string, X. 476  477  Output: 478  Block, Y. 479  480  Steps: 481  1. Let m = LEN(X)/128.  482  2. Let X1, …, Xm be the blocks for which X = X1 || … || Xm. 483  3. Let Y0 = 0128, and for j from 1 to m let Yj = CIPHK (Yj–1 Å Xj). 484  4.  Return Ym.  485  5 Mode Specifications 486  The specifications of the encryption and decryption algorithms for FF1 and FF3-1 are presented 487  in Sections 6.1 and 6.2, organized into prerequisites, inputs, outputs, steps, and descriptions of the 488  steps. In addition to the key and designated cipher function, the prerequisites for each mode are 489  the choices of 1) the base, radix, and 2) the range of lengths, [minlen .. maxlen], for the numeral 490  string inputs that the implementation supports. FF1 also has a prerequisite for the choice of the 491  maximum tweak length, maxTlen, that the implementation supports. For each mode, the 492  requirements on the values for the prerequisites are specified prior to the encryption and decryption 493  algorithms.  494  The parameter choices may affect interoperability. The behavior of an implementation when 495  presented with incorrect inputs is outside the scope of this Recommendation.  496  For each specification, the 128-bit input and output blocks of the designated block cipher, CIPHK, 497  are represented as strings of 16 bytes.  498  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  13  5.1 FF1 499  The specifications for the FF1.Encrypt and FF1.Decrypt functions are given in Algorithms 7 and 500  8 below. The tweak, T, is optional, in that it may be the empty string, with byte length t = 0. 501  The parameters radix, minlen, and maxlen in FF1.Encrypt and FF1.Decrypt shall meet the 502  following requirements: 503  • radix ∈ [2 .. 216],  504  • radix  minlen ≥ 1 000 000, and 505  • 2 ≤ minlen ≤ maxlen < 232. 506  507  Algorithm 7: FF1.Encrypt(K, T, X)  508  509  Prerequisites: 510  Designated cipher function, CIPH, of an approved 128-bit block cipher; 511  Key, K, for the block cipher;  512  Base, radix; 513  Range of supported message lengths, [minlen .. maxlen]; 514  Maximum byte length for tweaks, maxTlen.  515  516  Inputs: 517  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 518  Tweak T, a byte string of byte length t, such that t ∈ [0 .. maxTlen]. 519  520  Output: 521  Numeral string, Y, such that LEN(Y) = n. 522  523  Steps: 524  1. Let u = ën/2û; v = n – u. 525  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 526  3. Let b = é év × LOG(radix)ù/8ù.  527  4. Let d = 4 éb/4ù + 4. 528  5. Let P = [1]1 || [2]1 || [1]1 || [radix]3 || [10]1 || [u mod 256]1 || [n]4 || [t]4. 529  6. For i from 0 to 9: 530  i. Let Q = T || [0](−t−b−1) mod 16 || [i]1 || [NUMradix(B)]b. 531  ii. Let R = PRF(P || Q). 532  iii. Let S be the first d bytes of the following string of éd/16ù blocks: 533  R || CIPHK (R Å [1]16) || CIPHK (R Å [2]16) … CIPHK (R Å [éd/16ù – 1]16). 534  iv. Let y = NUM(S). 535  v. If i is even, let m = u; else, let m = v.  536  vi. Let c = (NUMradix (A) + y) mod radix m. 537  vii. Let C = STR  m radix (c). 538  viii.  Let A = B. 539  ix. Let B = C. 540  7. Return A || B.  541  542  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  14  Description 543  The “split” of the numeral string X into two substrings, A and B, is performed in Steps 1 and 2. If 544  n is even, LEN(A)=LEN(B); otherwise, LEN(A)=LEN(B)–1. The byte lengths b and d, which are used 545  in Steps 6i and 6iii, respectively, are defined in Steps 3 and 4.6 A fixed block, P, used as the initial 546  block for the invocation of the function PRF in Step 6ii, is defined in Step 5. An iteration loop for 547  the ten Feistel rounds of FF1 is initiated in Step 6, executing nine substeps for each round, as 548  follows: 549  The tweak T, the substringB, and the round number i, are encoded as a binary string Q, in Step 6i. 550  The function PRF is applied to the concatenation of P and Q in Step 6ii, to produce a block, R, 551  which is either truncated or expanded to a byte string, S, with the appropriate number of bytes, d, 552  in Step 6iii. (In Figure 1, S corresponds to the output of FK.) In Steps 6iv to 6vii, S is combined 553  with the substring A to produce a numeral string C in the same base and with the same length. (In 554  Figure 1, the combining of S with A is indicated by the “+” operation.) In particular, in Step 6iv, S 555  is converted to a number, y. In Step 6v, the length, m, of A for this Feistel round is determined. In 556  Step 6vi, y is added to the number represented by the substring A, and the result is reduced modulo 557  the mth power of radix, yielding a number, c, which is converted to a numeral string in Step 6vii. 558  In Steps 6viii and 6ix, the roles of A and B are swapped for the next round: the substring B is 559  renamed as the substring A, and the modified A (i.e., C) is renamed as B.  560  This completes one round of the Feistel structure in FF1. After the tenth round, the concatenation 561  of A and B is returned as the output in Step 7.  562  563  Algorithm 8: FF1.Decrypt(K, T, X)  564  565  Prerequisites: 566  Designated cipher function, CIPH, of an approved 128-bit block cipher; 567  Key, K, for the block cipher;  568  Base, radix; 569  Range of supported message lengths, [minlen .. maxlen]; 570  Maximum byte length for tweaks, maxTlen. 571  572  Inputs: 573  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 574  Tweak T, a byte string of byte length t, such that t ∈ [0 .. maxTlen]. 575  576  Output: 577  Numeral string, Y, such that LEN(Y) = n. 578  Steps: 579  1. Let u = ën/2û; v = n – u. 580  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 581  3. Let b = é év × LOG(radix) ù/8ù. 582  4. Let d = 4 éb/4ù + 4 583  5. Let P = [1]1 || [2]1 || [1]1 || [radix]3 || [10]1  || [u mod 256]1 || [n]4 || [t]4. 584  6 When B is encoded as a byte string in Step 6i, b is the number of bytes in the encoding. The definition of d ensures  that the output of the Feistel round function is at least four bytes longer than this encoding of B, which minimizes any  bias in the modular reduction in Step 6vi.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  15  6. For i from 9 to 0: 585  i. Let Q = T || [0](−t−b−1) mod 16 || [i]1 || [NUMradix (A)]b. 586  ii. Let R = PRF(P || Q). 587  iii. Let S be the string of the first d bytes of the following string of éd/16ù blocks: 588  R || CIPHK (R Å [1]16) || CIPHK (R Å [2]16) … CIPHK (R Å [éd/16ù – 1]16). 589  iv. Let y = NUM(S). 590  v. If i is even, let m = u; else, let m = v.  591  vi. Let c = (NUMradix (B) – y) mod radix m. 592  vii. Let C = STRm  radix (c). 593  viii.  Let B = A. 594  ix. Let A = C. 595  7. Return A || B.  596  597  Description: 598  The FF1.Decrypt algorithm is similar to the FF1.Encrypt algorithm; the differences are in Step 6, 599  where: 1) the order of the indices is reversed, 2) the roles of A and B are swapped, and 3) modular 600  addition is replaced by modular subtraction, in Step 6vi.  601  5.2 FF3-1 602  The specifications for the FF3-1.Encrypt and FF3-1.Decrypt functions are given in Algorithms 9 603  and 10 below. The parameters radix, minlen, and maxlen in FF3-1.Encrypt and FF3-1.Decrypt 604  shall meet the following requirements: 605  606  • radix ∈ [2 .. 216],  607  • radix  minlen ≥ 1 000 000, and  608  • 2 ≤ minlen ≤ maxlen ≤ 2 ëlog radix (296)û. 609  610  Algorithm 9: FF3-1.Encrypt(K, T, X)  611  612  Prerequisites: 613  Designated cipher function, CIPH, of an approved 128-bit block cipher; 614  Key, K, for the block cipher;  615  Base, radix; 616  Range of supported message lengths, [minlen .. maxlen]. 617  618  Inputs: 619  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 620  Tweak bit string, T, such that LEN(T) = 56. 621  622  623  Output: 624  Numeral string, Y, such that LEN(Y) = n. 625  626  Steps: 627  1. Let u = ⌈ n/2⌉; v = n – u. 628  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 629  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  16  3. Let TL = T [0 .. 27] || 04 and TR = T [32 .. 55] || T [28 .. 31] || 04. 630  4. For i from 0 to 7: 631  i. If i is even, let m = u and W = TR, else let m = v and W = TL. 632  ii. Let P = W ⊕ [i]4 || [NUMradix (REV(B))]12. 633  iii Let S = REVB(CIPHREVB(K) REVB(P)). 634  iv. Let y = NUM(S).  635  v. Let c = (NUMradix (REV(A)) + y) mod radix m.  636  vi.  Let C = REV(STRm  radix (c)). 637  vii.  Let A = B. 638  viii. Let B = C. 639  5. Return A || B.  640  641  Description: 642  The “split” of the numeral string X into two substrings, A and B, is performed in Steps 1 and 2. If 643  n is even, LEN(A)=LEN(B); otherwise, LEN(A)=LEN(B)+1.7 The tweak, T, is partitioned in Step 3 644  into a 32-bit left tweak, TL, and a 32-bit right tweak, TR. An iteration loop for the eight Feistel 645  rounds of FF3-1 is initiated in Step 4, executing eight substeps for each round, as follows: 646  647  In Step 4i, the parity of the round number, i, determines the length, m, of the substring A, and 648  whether TL or TR will be used as W in Step 4ii, in which a 32-bit encoding of i, XORed with W, is 649  concatenated with a 96-bit encoding of B to produce a block, P. In Step 4iii, the block cipher under 650  the key, is applied to P using the byte-reversed ordering convention, to produce a block, S. (In 651  Figure 1, S corresponds to the output of FK.) In Steps 4iv to 4vi, S is combined with the substring 652  A to produce a numeral string C in the same base and with the same length. (In Figure 1, the 653  combining of S with A is indicated by the “+” operation, although this operation is different than 654  for FF1 in that FF3-1 uses the opposite ordering convention for the conversion of strings to 655  numbers and vice versa.) In particular, in Step 4iv, S is converted to a number, y. In Step 4v, the 656  number y is added to the number represented by the substring A, and the result is reduced modulo 657  the mth power of radix, yielding a number, c, which is converted to a numeral string in Step 4vi. 658  In Steps 4vii and 4viii, the roles of A and B are swapped for the next round: the substring B is 659  renamed as the substring A, and the modified A (i.e., C) is renamed as B.  660  661  This completes one round of the Feistel structure in FF3-1. After the eighth round, the 662  concatenation of A and B is returned as the output in Step 5. 663  664  Algorithm 10: FF3-1.Decrypt(K, T, X)  665  666  Prerequisites: 667  Designated cipher function, CIPH, of an approved 128-bit block cipher; 668  Key, K, for the block cipher;  669  Base, radix; 670  Range of supported message lengths, [minlen .. maxlen]. 671  672  Inputs: 673  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 674  7 If n is odd, A is one numeral longer than B, in contrast to FF1, where B is one numeral longer than A.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  17  Tweak bit string, T, such that LEN(T ) = 64. 675  676  Output: 677  Numeral string, Y, such that LEN(Y ) = n. 678  679  Steps: 680  1. Let u = ⌈n /2⌉; v = n – u. 681  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 682  3. Let TL = T [0 .. 27] || 04 and TR = T [32 .. 55] || T [28 .. 31] || 04. 683  4. For i from 7 to 0: 684  i. If i is even, let m = u and W = TR, else let m = v and W =TL. 685  ii. P = W ⊕ [i]4 || [NUMradix (REV(A))]12.  686  iii Let S = REVB(CIPHREVB(K) REVB(P)). 687  iv. Let y = NUM(S).  688  v. Let c = (NUMradix (REV(B)) – y) mod radix m.  689  vi.  Let C = REV(STRm  radix (c)). 690  vii.  Let B = A. 691  viii. Let A = C. 692  5. Return A || B. 693  694  Description: 695  The FF3-1.Decrypt algorithm is similar to the FF3-1.Encrypt algorithm; the differences are in Step 696  4, where: 1) the order of the indices is reversed, 2) the roles of A and B are swapped, and  697  3) modular addition is replaced by modular subtraction, in Step 4v.  698  6 Conformance 699  Implementations of FF1.Encrypt, FF1.Decrypt, FF3-1.Encrypt, or FF3-1.Decrypt may be tested 700  for conformance to this Recommendation under the auspices of NIST’s Cryptographic Algorithm 701  Validation Program [12].  702  Component functions such as PRF are not approved for use independent of these four functions. 703  In order to claim conformance with this Recommendation, an implementation of FF1 or FF3-1 704  may support as few as one value for the base.  705  Two implementations can only interoperate when they support common values for the base. 706  Moreover, FF1 and FF3-1 have two parameters, minlen and maxlen, that determine the lengths for 707  the numeral strings that are supported by an implementation of the encryption or decryption 708  function for the mode. FF1 also has a parameter, maxTlen, that indicates the maximum supported 709  length of a tweak string. The selection of these parameters may also affect interoperability.  710  For every algorithm that is specified in this Recommendation, a conforming implementation may 711  replace the given set of steps with any mathematically equivalent set of steps. In other words, 712  different procedures that produce the correct output for any input are permitted. 713  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  18  Appendix A: Parameter Choices and Security 714  The values of the parameters, e.g., radix, minlen, and maxlen affect the security that FF1 and FF3-1 715  can offer, because, as for any FPE method, encrypted data may be vulnerable to guessing attacks 716  when the number of possible inputs is sufficiently small.  717  In particular, for a base radix numeral string S, there are radix LEN(S) possible values. For any 718  ciphertext C, the corresponding plaintext has the same length; therefore, an attacker can guess the 719  plaintext with probability 1/radix LEN(C) by selecting a numeral string of LEN(C) at random. 720  Repeated guesses increase the attacker’s probability of success proportionately: with g distinct 721  guesses, the probability is g/ radix LEN(C). 722  For example, SSNs are base 10 numeral strings of length 9, so there are one billion possibilities. 723  If an attacker could guess a thousand different values for an SSN, one of the guesses would be 724  correct with probability 1000/109, i.e., one in a million.  725  The original specifications of FF1and FF3 only imposed a modest absolute minimum of 100 on 726  the number of possible inputs in order to preclude a generic meet-in-the-middle attack on the 727  Feistel structure [17]. However, in order to mitigate guessing attacks and the analytic attacks 728  described in [1] and [8], the number of possible inputs, namely radix minlen, is required to be greater 729  than or equal to 1 000 000, for both FF1 and FF3-1. In order to further limit the effectiveness of 730  guessing attacks, implementations should also limit the number of guesses that an attacker can 731  mount, if possible. 732  In order to prevent attacks against one instance of encryption from applying to other instances, 733  implementations should enforce the use of different tweaks for different instances, as discussed in 734  Appendix C. Usually, tweaks are non-secret information that can be associated with instances of 735  encryption. For FF3-1, the tweak length is fixed, but for FF1 the maximum tweak length parameter, 736  maxTlen, should be chosen to accommodate the desired tweaks for the implementation.  737  Two other potential parameters of the Feistel structure are fixed for FF1 and FF3-1, namely, the 738  number of Feistel rounds and the imbalance, i.e., the values of the lengths u and v in Figure 1. Both 739  of these parameters were set with consideration to both performance and security requirements. 740  See Appendix H of [2] for a discussion.  741  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  19  Appendix B: Security Goal 742  The designers of FFX aimed to achieve strong-pseudorandom permutation (PRP) security for a 743  conventional block cipher [10]. In the FFX proposal to NIST [2], the designers of FFX cited the 744  history of cryptographic results concerning Feistel networks as underlying their selection of the 745  FFX mechanism. They asserted that, under the assumption that the underlying round function is 746  a good pseudorandom function (PRF), contemporary cryptographic results and experience 747  indicate that FFX achieved several cryptographic goals, including nonadaptive message-recovery 748  security, chosen-plaintext security, and even PRP-security against an adaptive chosen-ciphertext 749  attack. The quantitative security would depend on the number of rounds used, the imbalance, and 750  the adversary's access to plaintext-ciphertext pairs. See [2] for details.  751  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  20  Appendix C: Tweaks 752  Tweaks have been supported in stand-alone block ciphers, such as Schroeppel’s Hasty Pudding 753  [18], and the notion was later formalized and investigated by Liskov, Rivest, and Wagner [9]. 754  Tweaks are important for FPE modes, because FPE may be used in settings where the number of 755  possible character strings is relatively small. In such settings, the tweak should vary with each 756  instance of the encryption whenever possible. 757  For example, suppose that in an application for CCNs, the leading six digits and the trailing four 758  digits need to be available to the application, so that only the remaining six digits in the middle of 759  the CCNs are encrypted. There are a million different possibilities for these middle-six digits, so, 760  in a database of 100 million CCNs, about a hundred distinct CCNs would be expected to share 761  each possible value for these six digits. If the hundred CCNs that shared a given value for the 762  middle-six digits were encrypted with the same tweak, then their ciphertexts would be the same. 763  If, however, the other ten digits had been the tweak for the encryption of the middle-six digits, 764  then the hundred ciphertexts would almost certainly be different. 765  Similarly, in the encrypted database, about a hundred CCNs would be expected to share each 766  possible value for the ciphertext, i.e., the middle-six digits. If the hundred CCNs that produce a 767  given ciphertext had been encrypted with the same tweak, then the corresponding plaintexts would 768  also be the same. This outcome would be undesirable because the compromise of the 769  confidentiality of any of the hundred CCNs would reveal the others. 770  If, however, the leading six digits and the trailing four digits of the CCN had been used as the 771  tweak, then the corresponding plaintexts would almost certainly be different. Therefore, for 772  example, learning that the decryption of 111111-770611-1111 is 111111-123456-1111 would not 773  reveal any information about the decryption of 999999-770611-9999, because the tweak in that 774  case was different. 775  In general, if there is information that is available and statically associated with a plaintext, it is 776  recommended to use that information as a tweak for the plaintext. Ideally, the non-secret tweak 777  associated with a plaintext is associated only with that plaintext. 778  Extensive tweaking means that fewer plaintexts are encrypted under any given tweak. This 779  corresponds, in the security model that is described in [2], to fewer queries to the target instance 780  of the encryption.  781  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  21  Appendix D: Examples 782  Examples for FF1 and FF3-1 are available at the examples page on NIST’s Computer Security 783  Resource Center website: https://csrc.nist.gov/projects/cryptographic-standards-and-784  guidelines/example-values.  785  NIST SP 800-38G REV. 1 (DRAFT) BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  22  Appendix E: References 786  [1] M. Bellare, V. T. Hoang, and S. Tessaro, “Message-recovery attacks on Feistel-based787  Format Preserving Encryption,” in ACM CCS ’16, pages 444–455, ACM Press, 2016, 788  https://doi.org/10.1145/2976749.2978390.  789  [2] M. Bellare, P. Rogaway, and T. Spies, The FFX Mode of Operation for Format-790  Preserving Encryption, Draft 1.1, February 20, 2010, 791  https://csrc.nist.gov/csrc/media/projects/block-cipher-792  techniques/documents/bcm/proposed-modes/ffx/ffx-spec.pdf. 793  [3] M. Bellare, P. Rogaway, and T. Spies, Addendum to “The FFX Mode of Operation for794  Format-Preserving Encryption”: A parameter collection for enciphering strings of 795  arbitrary radix and length, Draft 1.0, September 3, 2010, 796  https://csrc.nist.gov/csrc/media/projects/block-cipher-797  techniques/documents/bcm/proposed-modes/ffx/ffx-spec2.pdf.  798  [4] E. Brier, T. Peyrin, and J. Stern, BPS: a Format-Preserving Encryption Proposal,799  [April 2010], https://csrc.nist.gov/csrc/media/projects/block-cipher-800  techniques/documents/bcm/proposed-modes/bps/bps-spec.pdf.  801  [5] Y-A. de Montjoye, L. Radaelli, V. Kumar Singh, and A. Pentland, “Unique in the802  shopping mall: On the reidentifiability of credit card metadata,” Science, vol. 347 no. 803  6221 (January 30, 2016), pp. 536-539, https://doi.org/10.1126/science.1256297.  804  [6] M. Dworkin and R. Perlner, Analysis of VAES3 (FF2), Report no. 2015/306, IACR805  Cryptology ePrint Archive, April 2, 2015, https://eprint.iacr.org/2015/306 806  [7] F. B. Durak and S. Vaudenay, “Breaking the FF3 Format-Preserving Encryption Standard807  Over Small Domains” in Advances in Cryptology—CRYPTO 2017, Lecture Notes in 808  Computer Science vol. 10402, Springer, pp. 679–707, https://doi.org/10.1007/978-3-319-809  63715-0_23.  810  [8] V.T. Hoang, S. Tessaro, N. Trieu, “The Curse of Small Domains: New Attacks on811  812  813  Format-Preserving Encryption” in Advances in Cryptology—CRYPTO 2018, Lecture  Notes in Computer Science 10991, Springer, Cham., pp. 221–251,  https://doi.org/10.1007/978-3-319-96884-1_8.  814  [9] M. Liskov, R. Rivest, and D. Wagner, “Tweakable block ciphers,” in Advances in815  Cryptology—CRYPTO 2002, Lecture Notes in Computer Science 2442, Berlin: Springer, 816  pp. 31–46, September 13, 2002, https://doi.org/10.1007/3-540-45708-9_3. 817  [10] M. Luby and C. Rackoff, “How to construct pseudorandom permutations from818  pseudorandom functions,” SIAM Journal on Computing, vol. 17 no. 2 (1988), pp. 373–819  386, https://doi.org/10.1137/0217022. 820  [11] National Institute of Standards and Technology, Explanation of changes to Draft SP 800-821  38G, June 27, 2014, https://csrc.nist.gov/news/2014/explanation-of-changes-to-draft-sp-822  800-38G.823  [12] National Institute of Standards and Technology, Cryptographic Algorithm Validation824  Program (CAVP), https://csrc.nist.gov/projects/cryptographic-algorithm-validation-825  program. 826  https://doi.org/10.1007/978-3-319-96884-1_8  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  23  [13] National Institute of Standards and Technology, Federal Information Processing Standard 827  (FIPS) 197, The Advanced Encryption Standard (AES), November 2001, 828  https://doi.org/10.6028/NIST.FIPS.197.  829  [14] National Institute of Standards and Technology. NIST Special Publication (SP) 800-38A, 830  Recommendation for Block Cipher Modes of Operation—Methods and Techniques, 831  December 2001, https://doi.org/10.6028/NIST.SP.800-38A.  832  [15] National Institute of Standards and Technology. NIST Special Publication (SP) 800-67 833  Revision 2, Recommendation for the Triple Data Encryption Algorithm (TDEA) Block 834  Cipher, January 2012, https://doi.org/10.6028/NIST.SP.800-67r2.  835  [16] National Institute of Standards and Technology. NIST Special Publication (SP) 800-133, 836  Recommendation for Cryptographic Key Generation, December 2012, 837  https://doi.org/10.6028/NIST.SP.800-133.  838  [17] J. Patarin, Generic attacks on Feistel schemes, Report no. 2008/036, IACR Cryptology 839  ePrint Archive, January 24, 2008, https://eprint.iacr.org/2008/036. 840  [18] R. Schroeppel, Hasty Pudding Cipher specification [Web page], June 1998 (revised May 841  1999), http://richard.schroeppel.name:8015/hpc/hpc-spec.  842  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  24  Appendix F: Revision History 843  A third mode, FF2—submitted to NIST under the name VAES3—was included in the initial draft 844  of this publication. As part of the public review of Draft NIST Special Publication (SP) 800-38G 845  and as part of its routine consultation with other agencies, NIST was advised by the National 846  Security Agency in general terms that the FF2 mode in the draft did not provide the expected 128 847  bits of security strength. NIST cryptographers confirmed this assessment via the security analysis 848  in [6] and announced the removal of FF2 in [11].  849  For both FF1 and FF3-1, the domain size, i.e., the number of possible input strings, is the quantity 850  radix  minlen. In response to the analysis in [8], the lower bound that is required for the domain size  851  in the specifications of both FF1 in Sec. 5.1 and FF3-1 in Sec. 5.2 was raised from one hundred in 852  the original publication to one million in Rev. 1. 853  854  The name “FF1” is unchanged from the original version of this publication, because the lower 855  bound on the domain size only affects which parameter combinations are approved, not the 856  specification of the encryption and decryption functions. FF3-1 has a different name than FF3 857  because, in addition to the new lower bound on the domain size, the encryption and decryption 858  functions of FF3 were revised.  859  860  In particular, in response to the analysis in [7] on FF3, the size of the tweak specified in Sec. 5.2 861  was reduced from 64 bits for FF3 to 56 bits for FF3-1, which entailed the modification of the 862  definitions of the strings TL and TR in Step 3 of Algorithm 9 and Step 3 of Algorithm 10.  The 863  modified definitions of these two strings can equivalently be implemented by taking a 64-bit 864  tweak, reordering some of its bits in a particular manner, and then forcing the bits in eight particular 865  bit positions to be zero. For tweaks with certain properties—for example, if non-zero bits only 866  occur in the leading 28 bit positions—the specification of FF3-1 is backwards compatible with the 867  original specification of FF3. 868",
    "original document": "Draft SP 800-38G Rev. 1, Recommendation for Block Cipher Modes of Operation: Methods for Format-Preserving Encryption  Draft NIST Special Publication 800-38G 1  Revision 1 2  Recommendation for Block Cipher 3  Modes of Operation 4  Methods for Format-Preserving Encryption 5  6  7  Morris Dworkin 8  9  10  11  12  13  14  15  This publication is available free of charge from: 16  https://doi.org/10.6028/NIST.SP.800-38Gr1-draft 17  18  19  20  C  O  M  P  U  T  E  R  S  E  C  U  R  I  T  Y 21  22  23  Draft NIST Special Publication 800-38G 24  Revision 1 25  26  Recommendation for Block Cipher 27  Modes of Operation  28  Methods for Format-Preserving Encryption 29  30  31  Morris Dworkin 32  Computer Security Division 33  Information Technology Laboratory 34  35  36  37  38  39  This publication is available free of charge from: 40  https://doi.org/10.6028/NIST.SP.800-38Gr1-draft 41  42  43  February 2019 44  45  46  47  48  49  U.S. Department of Commerce 50  Wilbur L. Ross, Jr., Secretary 51  52  National Institute of Standards and Technology  53  Walter Copan, NIST Director and Under Secretary of Commerce for Standards and Technology  54  Authority 55  This publication has been developed by NIST in accordance with its statutory responsibilities under the 56  Federal Information Security Modernization Act (FISMA) of 2014, 44 U.S.C. § 3551 et seq., Public Law 57  (P.L.) 113-283. NIST is responsible for developing information security standards and guidelines, including 58  minimum requirements for federal information systems, but such standards and guidelines shall not apply 59  to national security systems without the express approval of appropriate federal officials exercising policy 60  authority over such systems. This guideline is consistent with the requirements of the Office of Management 61  and Budget (OMB) Circular A-130. 62  Nothing in this publication should be taken to contradict the standards and guidelines made mandatory and 63  binding on federal agencies by the Secretary of Commerce under statutory authority. Nor should these 64  guidelines be interpreted as altering or superseding the existing authorities of the Secretary of Commerce, 65  Director of the OMB, or any other federal official. This publication may be used by nongovernmental 66  organizations on a voluntary basis and is not subject to copyright in the United States. Attribution would, 67  however, be appreciated by NIST. 68  69  70  71  72  National Institute of Standards and Technology Special Publication 800-38G Revision 1  Natl. Inst. Stand. Technol. Spec. Publ. 800-38G, 31 pages (February 2019)  CODEN: NSPUE2  This publication is available free of charge from:  https://doi.org/10.6028/NIST.SP.800-38Gr1-draft 73  Certain commercial entities, equipment, or materials may be identified in this document in order to describe an 74  experimental procedure or concept adequately. Such identification is not intended to imply recommendation or 75  endorsement by NIST, nor is it intended to imply that the entities, materials, or equipment are necessarily the best 76  available for the purpose. 77  There may be references in this publication to other publications currently under development by NIST in accordance 78  with its assigned statutory responsibilities. The information in this publication, including concepts and methodologies, 79  may be used by federal agencies even before the completion of such companion publications. Thus, until each 80  publication is completed, current requirements, guidelines, and procedures, where they exist, remain operative. For 81  planning and transition purposes, federal agencies may wish to closely follow the development of these new 82  publications by NIST 83  Organizations are encouraged to review all draft publications during public comment periods and provide feedback to 84  NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at 85  https://csrc.nist.gov/publications.86  Public comment period: February 28, 2019 through April 15, 2019 87  National Institute of Standards and Technology 88  Attn: Computer Security Division, Information Technology Laboratory 89  100 Bureau Drive (Mail Stop 8930) Gaithersburg, MD 20899-8930 90  Email: encryptionmodes@nist.gov  91  92  All comments are subject to release under the Freedom of Information Act (FOIA).93  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  i  Reports on Computer Systems Technology 94  95  The Information Technology Laboratory (ITL) at the National Institute of Standards and 96  Technology (NIST) promotes the U.S. economy and public welfare by providing technical 97  leadership for the Nation’s measurement and standards infrastructure. ITL develops tests, test 98  methods, reference data, proof of concept implementations, and technical analyses to advance the 99  development and productive use of information technology. ITL’s responsibilities include the 100  development of management, administrative, technical, and physical standards and guidelines for 101  the cost-effective security and privacy of other than national security-related information in federal 102  information systems. The Special Publication 800-series reports on ITL’s research, guidelines, and 103  outreach efforts in information system security, and its collaborative activities with industry, 104  government, and academic organizations. 105  Abstract 106  This Recommendation specifies two methods, called FF1 and FF3-1, for format-preserving 107  encryption. Both of these methods are modes of operation for an underlying, approved symmetric-108  key block cipher algorithm. Compared to the original version of this publication, the tweak size 109  for FF3-1 is smaller than the tweak size for FF3; also, for both FF1 and FF3-1, larger domains are 110  required, rather than merely recommended. 111  Keywords  112  Block cipher; confidentiality; encryption; FF1; FF3; FF3-1; format-preserving encryption; 113  information security; mode of operation.  114  115  116  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  ii  Acknowledgements 117  The author gratefully acknowledges the designers of the two algorithms that are specified in this 118  publication: 1) Mihir Bellare, Phil Rogaway, and Terence Spies; and 2) Eric Brier, Thomas Peyrin, 119  and Jacques Stern. 120  Serge Vaudenay and Betül Durak kindly gave NIST early notification of their analysis of the FF3 121  method in [7], which prompted the revision of the method in this version of the publication.  122  Similarly, Mihir Bellare, Viet Tung Hoang, Stefano Tessaro gave NIST early notification of their 123  analysis of the FPE modes in [1], which was subsequently improved by Hoang and Tessaro in their 124  paper with Ni Trieu [8].  These papers motivated the larger lower limit on the number of inputs 125  for both FF1 and FF3-1, which previously had been recommended but not required. 126  The author also wishes to thank his colleagues who reviewed drafts of this publication and 127  contributed to its development, especially Elaine Barker, Nicky Mouha, Lily Chen, John Kelsey, 128  Meltem Sonmez Turan, Kerry McKay, Allen Roginsky, Larry Bassham, Ray Perlner, Rene 129  Peralta, Jim Foti, Sara Kerman, Andy Regenscheid, Bill Burr, and Tim Polk. 130  The author also acknowledges the comments from the public and private sectors to improve the 131  quality of this publication. 132  Conformance Testing 133  Conformance testing for implementations of the functions that are specified in this publication will 134  be conducted within the framework of the Cryptographic Algorithm Validation Program (CAVP) 135  and the Cryptographic Module Validation Program (CMVP). The requirements on these 136  implementations are indicated by the word “shall.” Some of these requirements may be out-of-137  scope for CAVP or CMVP validation testing, and thus are the responsibility of entities using, 138  implementing, installing, or configuring applications that incorporate this Recommendation.  139  140  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  iii  Call for Patent Claims 141  142  This public review includes a call for information on essential patent claims (claims whose use 143  would be required for compliance with the guidance or requirements in this Information 144  Technology Laboratory (ITL) draft publication). Such guidance and/or requirements may be 145  directly stated in this ITL Publication or by reference to another publication. This call also includes 146  disclosure, where known, of the existence of pending U.S. or foreign patent applications relating 147  to this ITL draft publication and of any relevant unexpired U.S. or foreign patents. 148  149  ITL may require from the patent holder, or a party authorized to make assurances on its behalf, in 150  written or electronic form, either: 151  152  a) assurance in the form of a general disclaimer to the effect that such party does not hold and does 153  not currently intend holding any essential patent claim(s); or 154  155  b) assurance that a license to such essential patent claim(s) will be made available to applicants 156  desiring to utilize the license for the purpose of complying with the guidance or requirements in 157  this ITL draft publication either: 158  159  i) under reasonable terms and conditions that are demonstrably free of any unfair 160  discrimination; or 161  162  ii) without compensation and under reasonable terms and conditions that are demonstrably 163  free of any unfair discrimination. 164  165  Such assurance shall indicate that the patent holder (or third party authorized to make assurances 166  on its behalf) will include in any documents transferring ownership of patents subject to the 167  assurance, provisions sufficient to ensure that the commitments in the assurance are binding on 168  the transferee, and that the transferee will similarly include appropriate provisions in the event of 169  future transfers with the goal of binding each successor-in-interest. 170  171  The assurance shall also indicate that it is intended to be binding on successors-in-interest 172  regardless of whether such provisions are included in the relevant transfer documents. 173  174  Such statements should be addressed to: EncryptionModes@nist.gov.  175  176  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  iv  Table of Contents 177  178  1  Purpose .................................................................................................................... 1 179  2  Introduction ............................................................................................................. 1 180  3  Definitions and Notation ......................................................................................... 2 181  3.1  Definitions ........................................................................................................ 2 182  3.2  Acronyms ......................................................................................................... 4 183  3.3  Operations and Functions ................................................................................ 5 184  4  Preliminaries ............................................................................................................ 6 185  4.1  Representation of Character Strings ................................................................ 6 186  4.2  Underlying Block Cipher and Key .................................................................... 7 187  4.3  Encryption and Decryption Functions .............................................................. 8 188  4.4  Feistel Structure ............................................................................................... 8 189  4.5  Component Functions .................................................................................... 10 190  5  Mode Specifications .............................................................................................. 12 191  5.1  FF1 ................................................................................................................. 13 192  5.2  FF3-1 ............................................................................................................. 15 193  6  Conformance ......................................................................................................... 17 194  Appendix A: Parameter Choices and Security .......................................................... 18 195  Appendix B: Security Goal .......................................................................................... 19 196  Appendix C: Tweaks .................................................................................................... 20 197  Appendix D: Examples ................................................................................................. 21 198  Appendix E: References .............................................................................................. 22 199  Appendix F: Revision History ..................................................................................... 24 200  201  List of Figures 202  203  Figure 1: Feistel Structure .................................................................................................... 9 204  205  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  1  1 Purpose 206  This publication is a revision of the seventh part in a series of Recommendations regarding the 207  modes of operation of block cipher algorithms. The purpose of this part is to provide two approved 208  methods for format-preserving encryption (FPE).  209  Since the original publication of these FPE modes in March of 2016, researchers identified 210  vulnerabilities in [8], building on the work in [1], and in [7]. The present revision includes sets of 211  technical revisions to mitigate the vulnerabilities, as summarized in Appendix F.  212  2 Introduction 213  A block cipher mode of operation—or simply, mode—is an algorithm for the cryptographic 214  transformation of data that is based on a block cipher. The previously approved modes for 215  encryption are transformations on binary data, i.e., the inputs and outputs of the modes are bit 216  strings—sequences of ones and zeros. For sequences of non-binary symbols, however, there is no 217  natural and general way for the previously approved modes to produce encrypted data that has the 218  same format. For example, a Social Security Number (SSN) consists of nine decimal digits, so it 219  is an integer that is less than one billion. This integer can be converted to a bit string as input to a 220  previously approved mode, but when the output bit string is converted back to an integer, it may 221  be greater than one billion, which would be too long for an SSN.  222  FPE is designed for data that is not necessarily binary. In particular, given any finite set of symbols, 223  like the decimal numerals, a method for FPE transforms data that is formatted as a sequence of the 224  symbols in such a way that the encrypted form of the data has the same format, including the 225  length, as the original data. Thus, an FPE-encrypted SSN would be a sequence of nine decimal 226  digits. 227  FPE facilitates the targeting of encryption to sensitive information, as well as the retrofitting of 228  encryption technology to legacy applications, where a conventional encryption mode might not be 229  feasible. For example, database applications may not support changes to the length or format of 230  data fields. FPE has emerged as a useful cryptographic tool, whose applications include financial-231  information security, data sanitization, 1  and the transparent encryption of fields in legacy 232  databases. 233  The two FPE modes specified in this publication are called FF1 and FF3-1. FF3-1 is a revision of 234  the FF3 mode that was specified in the original version of this publication; the revision of FF3, as 235  well as a modified requirement for both FF1 and FF3-1, are described in Appendix F. The 236  acronyms for the modes indicate that they are format-preserving, Feistel-based encryption modes. 237  FF1 was submitted to NIST under the name FFX[Radix] in [3]. FF3 is a component of the FPE 238  method that was submitted to NIST under the name BPS in [4]. In particular, FF3 is essentially 239  equivalent to the BPS-BC component of BPS, instantiated with a 128-bit block cipher. The full 240  BPS mode—in particular, its chaining mechanism for longer input strings—is not approved in this 241  publication. 242  1 The sanitization of personally identifiable information in a database—whether by FPE or other methods—does not  necessarily provide strong assurance that individuals cannot be re-identified; for example, see [5].  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  2  Each of these FPE modes fits within a larger framework, called FFX, for constructing FPE 243  mechanisms; FFX was submitted to NIST in [2]. The “X” indicates the flexibility to instantiate the 244  framework with different parameter sets, as well as FFX’s evolution from its precursor, the Feistel 245  Finite Set Encryption Mode.  246  The FFX framework itself is not specified in this publication; in fact, FF1 and FF3-1 are not 247  presented explicitly as instantiations of FFX parameter sets, but rather as separate algorithms, in 248  order to simplify the individual specifications. 249  FF1 and FF3-1 each employ the Feistel structure—see Sec. 4.4—which also underlies the Triple 250  Data Encryption Algorithm (TDEA) [15]. At the core of FF1 and FF3-1 are somewhat different 251  Feistel round functions that are derived from an approved block cipher with 128-bit blocks, i.e., 252  the Advanced Encryption Standard (AES) algorithm [12]. 253  In addition to the formatted data for which the modes provide confidentiality, each mode also takes 254  an additional input called the “tweak,” which is not necessarily secret. The tweak can be regarded 255  as a changeable part of the key, because together they determine the encryption and decryption 256  functions. Tweaks that vary can be especially important for implementations of FPE modes, 257  because the number of possible values for the confidential data is often relatively small, as 258  discussed in Appendix A and Appendix C. 259  FF1 and FF3-1 offer somewhat different performance advantages. FF1 supports a greater range of 260  lengths for the protected, formatted data, as well as flexibility in the length of the tweak. FF3-1 261  achieves greater throughput, mainly because it has eight rounds, compared to ten for FF1.  262  3 Definitions and Notation 263  3.1 Definitions 264  alphabet A finite set of two or more symbols.  approved  FIPS-approved or NIST-recommended: an algorithm or technique that is either  1) specified in a FIPS or a NIST Recommendation, or 2) adopted in a Federal  Information Processing Standard (FIPS) or a NIST Recommendation.  base The number of characters in a given alphabet. The base is denoted by radix.  bit A binary digit: 0 or 1.  bit string  A finite, ordered sequence of bits.  block  For a given block cipher, a bit string whose length is the block size of the block  cipher.  block cipher A parameterized family of permutations on bit strings of a fixed length; the  parameter that determines the permutation is a bit string called the key.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  3  block cipher  mode of  operation  An algorithm for the cryptographic transformation of data that is based on a  block cipher.  block size For a given block cipher and key, the fixed length of the input (or output) bit  strings.  block string A bit string whose length is a multiple of a given block size, so that it can be  represented as the concatenation of a finite sequence of blocks.  byte A string of eight bits.  byte string A bit string whose length is a multiple of eight bits, so that it can be represented  as the concatenation of a finite sequence of bytes.  character A symbol in a given alphabet.  character string A finite, ordered sequence of characters from a given alphabet.  ciphertext In this publication, the numeral string that is the encrypted form of a plaintext  numeral string.  decryption  function  For a given block cipher and key, the function of an FPE mode that takes a  ciphertext numeral string and a tweak as input and returns the corresponding  plaintext numeral string as output.  designated  cipher function  For a given block cipher and key, the choice of either the forward  transformation or the inverse transformation.  encryption  function  For a given block cipher and key, the function of an FPE mode that takes a  plaintext numeral string and a tweak as input and returns a ciphertext numeral  string as output.  exclusive-OR  (XOR)  The bitwise addition, modulo 2, of two bit strings of equal length.  Feistel structure  A framework for constructing an encryption mode. The framework consists of  several iterations, called rounds, in which a keyed function, called the round  function, is applied to one part of the data in order to modify the other part of  the data; the roles of the two parts are swapped for the next round.  forward  transformation  For a given block cipher, the permutation of blocks that is determined by the  choice of a key.  inverse  transformation For a given block cipher, the inverse of the forward transformation .  key For a given block cipher, the secret bit string that parameterizes the  permutation.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  4  3.2 Acronyms 265  AES Advanced Encryption Standard.  CAVP Cryptographic Algorithm Validation Program.  CCN credit card number.  CMVP Cryptographic Module Validation Program.  FIPS Federal Information Processing Standard.  FISMA Federal Information Security Management Act.  FPE format-preserving encryption.  IETF Internet Engineering Task Force.  ITL Information Technology Laboratory.  NIST National Institute of Standards and Technology.  PRF pseudorandom function.  PRP pseudorandom permutation.  RFC Request for Comment.  SSN Social Security number.  266  mode See block cipher mode of operation.  numeral For a given base, a nonnegative integer less than the base.  numeral string For a given base, a finite, ordered sequence of numerals for the base.  plaintext In this publication, a numeral string whose confidentiality is protected by an  FPE mode.  prerequisite A required input to an algorithm that has been established prior to the  invocation of the algorithm.  shall Is required to. Requirements apply to conforming implementations.  should Is recommended to.  tweak The input parameter to the encryption and decryption functions whose  confidentiality is not necessarily protected by the mode.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  5  3.3 Operations and Functions 267  BYTELEN(X)  The number of bytes in a byte string, X, which may be represented as a bit  string.  For example, BYTELEN(1011100110101100) = 2.  CIPHK (X) The output of the designated cipher function of the block cipher under the  key K applied to the block X.  LEN(X) The number of numerals/bits in a numeral/bit string X.  For example,  LEN(010) = 3.  LOG(x) The base 2 logarithm of the real number x > 0. For example, LOG(64) = 6  and LOG(10) ≈ 3.32.  NUM(X)  The integer that a bit string X represents when the bits are valued in  decreasing order of significance. For example, NUM(10000000) = 128. An  algorithm for computing NUM(X) is given in Sec. 4.5.  NUMradix (X)  The number that the numeral string X represents in base radix when the  numerals are valued in decreasing order of significance. For example,  NUM5 (00011010) = 755. An algorithm for computing NUM radix (X) is given  in Sec. 4.5.  PRF(X) The output of the function PRF applied to the block X; PRF is defined in terms  of a given designated cipher function.  REV(X) Given a numeral string, X, the numeral string that consists of the numerals  of X in reverse order. For example, in base ten, REV(13579) = 97531.  REVB(X) Given a byte string, X, the byte string that consists of the bytes of X in  reverse order. For example, REVB([1]1  || [2]1  || [3]1) = [3]1  || [2]1  || [1]1.  STRm radix (x)  Given a nonnegative integer x less than radixm, the representation of x as a  string of m numerals in base radix, in decreasing order of significance. For  example, STR 4  12  (559) is the string of four numerals in base 12 that represents  559, namely, 0 3 10 7. An algorithm for computing STR mradix (x) is given in  Sec. 4.5.  ⌊x⌋ The floor function: given a real number x, the greatest integer that does not  exceed x.  For example, ⌊2.1⌋ = 2, and ⌊4⌋ = 4.  éxù The ceiling function:  given a real number x, the least integer that is not less  than x.  For example, é2.1ù = 3, and é4ù = 4.  [x]s Given a nonnegative integer x less than 256 s, the representation of x as a  string of s bytes. For example, [5]1 = 00000000 00000101.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  6  4 Preliminaries 268  4.1 Representation of Character Strings 269  The data inputs and outputs for FF1 and FF3-1 are sequences of numbers that can represent both 270  numeric and non-numeric data, as discussed below. 271  A finite set of two or more symbols is called an alphabet. The symbols in an alphabet are called 272  the characters of the alphabet. The number of characters in an alphabet is called the base, denoted 273  by radix; thus, radix ≥ 2. 274  A character string is a finite sequence of characters from an alphabet; individual characters may 275  repeat in the string. In this publication, character strings (and bit strings) are presented in the 276  Courier New font.  277  Thus, for the alphabet of lower-case English letters, 278  {a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z}, 279  hello and cannot are character strings, but Hello and can’t are not, because the symbols 280  “H” and “ ′ ” are not in the alphabet. 281  SSNs or Credit Card Numbers (CCNs) can be regarded as character strings in the alphabet of base 282  ten numerals, namely, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. The notion of numerals is generalized to any 283  given base as follows: the set of base radix numerals is 284  {0, 1, …, radix-1}. 285  [i .. j] The set of integers between two integers i and j, including i and j. For  example, [2 .. 5] = {2, 3, 4, 5}.  x mod m The nonnegative remainder of the integer x modulo the positive integer m,  i.e., x – m⌊x/m⌋. For example, 13 mod 7 = 6, and -3 mod 7 = 4.  X [i] Given a numeral/bit string X and an index i such that 1 ≤ i ≤ LEN(X), the i th  numeral/bit of X. For example, in base ten, if X = 798137, then X [2] = 9.  X [i .. j] The substring of the string X from X [i] to X [j], including X [i] and X [j].  For  example, in base ten, if X = 798137, then X [3 .. 5] = 813.  X ⊕ Y  The bitwise exclusive-OR of bit strings X and Y whose bit lengths are equal.  For example, 10011 ⊕ 10101 = 00110.  X || Y The concatenation of numeral strings X and Y.  For example,  001 || 1011 = 0011011, and 3 1 || 31 8 10 = 3 1 31 8 10.  0s  The bit string that consists of s consecutive ‘0’ bits. For example,  08 = 00000000.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  7  The data inputs and outputs to the FF1 and FF3-1 encryption and decryption functions must be 286  finite sequences of numerals, i.e., numeral strings. If the data to be encrypted is formatted in an 287  alphabet that is not already the set of base radix numerals, then each character must be represented 288  by a distinct numeral in order to apply FF1 or FF3-1.  289  For example, the natural representation of lower-case English letters with base 26 numerals is  290  a→0, b→1, c→2, … x→23, y→24, z→25. 291  The character string hello would then be represented by the numeral string 7 4 11 11 14. Other 292  representations are possible.  293  The choice and implementation of a one-to-one correspondence between a given alphabet and the 294  set of base radix numerals that represents the alphabet is outside the scope of this publication. 295  In this publication, individual numerals are themselves represented in base ten. In order to display 296  numeral sequences unambiguously when the base is greater than ten, a delimiter between the 297  numerals is required, such as a space (as in the base 26 example above) or a comma. 298  FF1 and FF3-1 use different conventions for interpreting numeral strings as numbers. For FF1, 299  numbers are represented by strings of numerals with decreasing order of significance; for FF3-1, 300  numbers are represented by strings of numerals in the reverse order, i.e., with increasing order of 301  significance. For example, “0025” is a string of decimal digits that represents the number twenty-302  five for FF1 and the number five thousand two hundred for FF3-1. Algorithms for the functions 303  that convert numeral strings to numbers and vice versa are given in Sec. 4.5.  304  4.2 Underlying Block Cipher and Key 305  The encryption and decryption functions of FF1 and FF3-1 feature a block cipher as the main 306  component; thus, each of these FPE mechanisms is a mode of operation (mode, for short) of the 307  block cipher.  308  For any given key, K, the underlying block cipher of the mode is a permutation, i.e., an invertible 309  transformation on bit strings of a fixed length; the fixed-length bit strings are called blocks, and 310  the length of a block is called the block size. For an FPE mode, as part of the choice of the 311  underlying block cipher with the key, either the forward transformation or the inverse 312  transformation2 is specified as the designated cipher function, denoted by CIPHK. The inverse of 313  CIPHK is not needed for the modes that are specified in this publication.  314  For both modes, the underlying block cipher shall be approved, and the block size shall be 128 315  bits. Currently, the AES block cipher [12], with key lengths of 128, 192, or 256 bits, is the only 316  block cipher that fits this profile.  317  The choice of the key length affects the security of the FPE modes, e.g., against brute-force search, 318  and also affects the details of the implementation of the AES algorithm. Otherwise, the key length 319  does not affect the implementation of FF1 and FF3-1, and the choice of the key length is not 320  2 The forward transformation and the inverse transformations are sometimes referred to as the “encrypt” and “decrypt”  functions, respectively, of the block cipher; however, in this publication, “encrypt” and “decrypt” are reserved for  functions of the FPE modes.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  8  explicitly indicated in their specifications. Methods for generating cryptographic keys are 321  discussed in [16]; the goal is to select the keys uniformly at random, i.e., for each possible key to 322  occur with equal probability.  323  The key shall be kept secret, i.e., disclosed only to parties that are authorized to know the protected 324  information. Compliance with this requirement is the responsibility of the entities using, 325  implementing, installing, or configuring applications that incorporate the functions that are 326  specified in this publication. The management of cryptographic keys is outside the scope of this 327  publication. 328  4.3 Encryption and Decryption Functions 329  For a given key, denoted by K, for the designated block cipher, FF1 and FF3-1 each consist of two 330  related functions: encryption and decryption. The inputs to the encryption function are a numeral 331  string called the plaintext, denoted by X, and a byte string, called the tweak, denoted by T; the 332  function returns a numeral string called the ciphertext, denoted by Y, with the same length as X. 333  Similarly, the inputs to the decryption function are a numeral string X and a tweak T; the output is 334  a numeral string Y of the same length as X.  335  For FF1, the encryption function is denoted by FF1.Encrypt(K, T, X), and the decryption function 336  is denoted by FF1.Decrypt(K, T, X), with analogous notation for FF3-1. 337  For a given tweak, the decryption function is the inverse of the encryption function, so that  338  FF1.Decrypt(K, T, FF1.Encrypt(K, T, X)) = X, 339  FF3-1.Decrypt(K, T, FF3-1.Encrypt(K, T, X)) = X. 340  341  The tweak does not need to be kept secret; often, it is some readily available data that is associated 342  with the plaintext. Although implementations may fix the value of the tweak, variable tweaks 343  should be used as a security enhancement; see Appendix C. In FF1 and FF3-1, tweaks are byte 344  strings. The specifications in Sec. 5 include the lengths that can be supported for the tweak, as well 345  as for the plaintext/ciphertext. 346  The key, K, is indicated in the above notation as an input for the encryption and decryption 347  functions; however, in the specifications in this publication, the key is listed as a prerequisite, i.e., 348  an input that is usually established prior to the invocation of the function. 3  Several other 349  prerequisites are omitted from the above notation, such as the underlying block cipher, the 350  designation of CIPHK, and the base for the numeral strings. 351  4.4 Feistel Structure 352  FFX schemes, including FF1 and FF3-1, are based on the Feistel structure. The Feistel structure 353  consists of several iterations, called rounds, of a reversible transformation. The transformation 354  consists of three steps: 1) the data is split into two parts; 2) a keyed function, called the round 355  function, is applied to one part of the data in order to modify the other part of the data; and 3) the 356  roles of the two parts are swapped for the next round. The structure is illustrated in Figure 1 below, 357  3 The distinction does not affect the execution of the function: all information is required, independent of when they  were established or provided to the implementation.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  9  for both encryption and decryption. Four rounds are shown in Figure 1, but ten rounds are actually 358  specified for FF1, and eight rounds for FF3-1. 359  360  361  Figure 1: Feistel Structure  362  For the encryption function example in Figure 1, the rounds are indexed from 0 to 3. The input 363  data (and output data) for each round are two strings of characters—which will be numerals for 364  FF1 and FF3-1. The lengths of the two strings are denoted by u and v, and the total number of 365  characters is denoted by n, so that u + v = n. During Round i, the round function, denoted by FK, is 366  applied to one of the input strings, denoted by Bi, with the length n, the tweak T, and the round 367  number i as additional inputs. (In Figure 1, this triple (n, T, i) of additional inputs is indicated 368  within the dotted rectangles, with the appropriate values for i). The result is used to modify the 369  other string, denoted by Ai, via modular addition4, indicated by +, on the numbers that the strings 370  4 For some applications of the Feistel structure—but not FF1 and FF3-1—the “+” operation may be a different  reversible operation on strings that preserves their length; for example, the FFX specification in [2] supports an option  for character-wise addition.  u!characters! v!characters!  B1!←!C0! A1!←!B0!  FK!  +! n,!T,!0!  A0! B0!  FK!  +!n,!T,!1!  A2!←!B1! B2!←!C1!  B3!←!C2! A3!←!B2!  FK!  +! n,!T,!2!  FK!  +!n,!T,!3!  A4!←!B3! B4!←!C3!  u!characters! v!characters!  B1!←!A2! A1!  A0! B0!←!A1!  A2!! B2!←!A3!  B3!←!A4! A3!!  A4!! B4!  FK!  _! n,!T,!2!  FK!  _! n,!T,!0!  FK!  _!n,!T,!3!  FK!  _!n,!T,!1!  Encryption! Decryption!  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  10  represent5. The string that represents the resulting number is named with a temporary variable, Ci. 371  The names of the two parts are swapped for the next round, so that the modified Ai, i.e., Ci, becomes 372  Bi+1, and Bi becomes Ai+1.  373  The rectangles containing the two parts of the data have different sizes in order to illustrate that u 374  cannot equal v if n is odd. In such cases, the round function is constructed so that the lengths of its 375  input and output strings depend on whether the round number index, i, is even or odd.  376  The Feistel structure for decryption is almost identical to the Feistel structure for encryption. There 377  are three differences: 1) the order of the round indices is reversed; 2) the roles of the two parts of 378  the data in the round function are swapped as follows: along with n, T, and i, the input to FK is Ai+1 379  (not Bi), and the output is combined with Bi+1 (not Ai) to produce Ai (not Bi+1); and 3) modular 380  addition (of the output of FK to Ai) is replaced by modular subtraction (of the output of FK from 381  Bi +1).  382  4.5 Component Functions 383  This section gives algorithms for the component functions that are called in the specifications of 384  FF1 and FF3-1. The conversion functions NUMradix(X), NUM(X), and STRm  radix(x) are defined in 385  Sec. 3.3, including examples, and they are specified in Algorithms 1-3 below. These functions 386  support the ordering convention for the numeral/bit strings in FF1, namely, that the first (i.e., left-387  most) numeral/bit of the string is the most-significant numeral/bit 388  In FF3-1, the numeral strings follow the opposite ordering convention, as do the byte strings for 389  the block cipher. In order to adapt NUMradix(X), STRm  radix (x), and CIPHK (X) for the FF3-1 390  specifications, the functions REV(X) and REVB(X) are defined in Sec. 3.3 and specified in 391  Algorithms 4 and 5. 392  The PRF(X) function, specified in Algorithm 6, essentially invokes the Cipher Block Chaining 393  encryption mode [14] on the input bit string and returns the final block of the ciphertext; this 394  function is the pseudorandom core of the Feistel round function for FF1.Encrypt and FF1.Decrypt.  395  In order to simplify the specifications of NUM(X), REVB(X), and PRF(X), the byte or block strings 396  in Algorithms 2, 5, and 6 are represented as bit strings.  397  Algorithm 1: NUMradix (X)  398  399  Prerequisite: 400  Base, radix. 401  402  Input: 403  Numeral string, X. 404  405  Output: 406  Number, x. 407  408  409  5 The ordering convention for interpreting strings as numbers is different for FF3-1 than for FF1.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  11  Steps: 410  1. Let x = 0. 411  2. For i from 1 to LEN(X), let x = x × radix + X [i]. 412  3. Return x. 413  414  Algorithm 2: NUM(X)  415  416  Input: 417  Byte string, X, represented in bits. 418  419  Output: 420  Integer, x. 421  422  Steps: 423  1. Let x = 0. 424  2. For i from 1 to LEN(X), let x = 2 x + X [i]. 425  3. Return x. 426  427  Algorithm 3: STRm radix (x) 428  429  Prerequisites: 430  Base, radix; 431  String length, m. 432  433  Input: 434  Integer, x, such that 0 ≤ x < radixm. 435  436  Output: 437  Numeral string, X. 438  439  Steps: 440  1. For i from 1 to m: 441  i. X [m + 1– i] = x mod radix;  442  ii. x = ëx/radixû. 443  2.  Return X. 444  Algorithm 4: REV(X )  445  446  Input: 447  Numeral string, X. 448  449  Output: 450  Numeral string, Y. 451  452  Steps: 453  1.  For i from 1 to LEN(X), let Y [i] = X [LEN(X) + 1 – i]. 454  2.  Return Y [1 .. LEN(X)].  455  456  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  12  Algorithm 5: REVB(X)  457  458  Input: 459  Byte string, X, represented in bits. 460  461  Output: 462  Byte string, Y, represented in bits. 463  464  Steps: 465  1.  For i from 0 to BYTELEN(X) – 1 and j from 1 to 8, let Y [8i + j] = X [8 × (BYTELEN(X) – 1– i) + j]. 466  2.  Return Y [1 .. 8 × BYTELEN(X)].  467  468  Algorithm 6: PRF(X)  469  470  Prerequisites: 471  Designated cipher function, CIPH, of an approved 128-bit block cipher; 472  Key, K, for the block cipher. 473  474  Input:  475  Block string, X. 476  477  Output: 478  Block, Y. 479  480  Steps: 481  1. Let m = LEN(X)/128.  482  2. Let X1, …, Xm be the blocks for which X = X1 || … || Xm. 483  3. Let Y0 = 0128, and for j from 1 to m let Yj = CIPHK (Yj–1 Å Xj). 484  4.  Return Ym.  485  5 Mode Specifications 486  The specifications of the encryption and decryption algorithms for FF1 and FF3-1 are presented 487  in Sections 6.1 and 6.2, organized into prerequisites, inputs, outputs, steps, and descriptions of the 488  steps. In addition to the key and designated cipher function, the prerequisites for each mode are 489  the choices of 1) the base, radix, and 2) the range of lengths, [minlen .. maxlen], for the numeral 490  string inputs that the implementation supports. FF1 also has a prerequisite for the choice of the 491  maximum tweak length, maxTlen, that the implementation supports. For each mode, the 492  requirements on the values for the prerequisites are specified prior to the encryption and decryption 493  algorithms.  494  The parameter choices may affect interoperability. The behavior of an implementation when 495  presented with incorrect inputs is outside the scope of this Recommendation.  496  For each specification, the 128-bit input and output blocks of the designated block cipher, CIPHK, 497  are represented as strings of 16 bytes.  498  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  13  5.1 FF1 499  The specifications for the FF1.Encrypt and FF1.Decrypt functions are given in Algorithms 7 and 500  8 below. The tweak, T, is optional, in that it may be the empty string, with byte length t = 0. 501  The parameters radix, minlen, and maxlen in FF1.Encrypt and FF1.Decrypt shall meet the 502  following requirements: 503  • radix ∈ [2 .. 216],  504  • radix  minlen ≥ 1 000 000, and 505  • 2 ≤ minlen ≤ maxlen < 232. 506  507  Algorithm 7: FF1.Encrypt(K, T, X)  508  509  Prerequisites: 510  Designated cipher function, CIPH, of an approved 128-bit block cipher; 511  Key, K, for the block cipher;  512  Base, radix; 513  Range of supported message lengths, [minlen .. maxlen]; 514  Maximum byte length for tweaks, maxTlen.  515  516  Inputs: 517  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 518  Tweak T, a byte string of byte length t, such that t ∈ [0 .. maxTlen]. 519  520  Output: 521  Numeral string, Y, such that LEN(Y) = n. 522  523  Steps: 524  1. Let u = ën/2û; v = n – u. 525  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 526  3. Let b = é év × LOG(radix)ù/8ù.  527  4. Let d = 4 éb/4ù + 4. 528  5. Let P = [1]1 || [2]1 || [1]1 || [radix]3 || [10]1 || [u mod 256]1 || [n]4 || [t]4. 529  6. For i from 0 to 9: 530  i. Let Q = T || [0](−t−b−1) mod 16 || [i]1 || [NUMradix(B)]b. 531  ii. Let R = PRF(P || Q). 532  iii. Let S be the first d bytes of the following string of éd/16ù blocks: 533  R || CIPHK (R Å [1]16) || CIPHK (R Å [2]16) … CIPHK (R Å [éd/16ù – 1]16). 534  iv. Let y = NUM(S). 535  v. If i is even, let m = u; else, let m = v.  536  vi. Let c = (NUMradix (A) + y) mod radix m. 537  vii. Let C = STR  m radix (c). 538  viii.  Let A = B. 539  ix. Let B = C. 540  7. Return A || B.  541  542  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  14  Description 543  The “split” of the numeral string X into two substrings, A and B, is performed in Steps 1 and 2. If 544  n is even, LEN(A)=LEN(B); otherwise, LEN(A)=LEN(B)–1. The byte lengths b and d, which are used 545  in Steps 6i and 6iii, respectively, are defined in Steps 3 and 4.6 A fixed block, P, used as the initial 546  block for the invocation of the function PRF in Step 6ii, is defined in Step 5. An iteration loop for 547  the ten Feistel rounds of FF1 is initiated in Step 6, executing nine substeps for each round, as 548  follows: 549  The tweak T, the substringB, and the round number i, are encoded as a binary string Q, in Step 6i. 550  The function PRF is applied to the concatenation of P and Q in Step 6ii, to produce a block, R, 551  which is either truncated or expanded to a byte string, S, with the appropriate number of bytes, d, 552  in Step 6iii. (In Figure 1, S corresponds to the output of FK.) In Steps 6iv to 6vii, S is combined 553  with the substring A to produce a numeral string C in the same base and with the same length. (In 554  Figure 1, the combining of S with A is indicated by the “+” operation.) In particular, in Step 6iv, S 555  is converted to a number, y. In Step 6v, the length, m, of A for this Feistel round is determined. In 556  Step 6vi, y is added to the number represented by the substring A, and the result is reduced modulo 557  the mth power of radix, yielding a number, c, which is converted to a numeral string in Step 6vii. 558  In Steps 6viii and 6ix, the roles of A and B are swapped for the next round: the substring B is 559  renamed as the substring A, and the modified A (i.e., C) is renamed as B.  560  This completes one round of the Feistel structure in FF1. After the tenth round, the concatenation 561  of A and B is returned as the output in Step 7.  562  563  Algorithm 8: FF1.Decrypt(K, T, X)  564  565  Prerequisites: 566  Designated cipher function, CIPH, of an approved 128-bit block cipher; 567  Key, K, for the block cipher;  568  Base, radix; 569  Range of supported message lengths, [minlen .. maxlen]; 570  Maximum byte length for tweaks, maxTlen. 571  572  Inputs: 573  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 574  Tweak T, a byte string of byte length t, such that t ∈ [0 .. maxTlen]. 575  576  Output: 577  Numeral string, Y, such that LEN(Y) = n. 578  Steps: 579  1. Let u = ën/2û; v = n – u. 580  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 581  3. Let b = é év × LOG(radix) ù/8ù. 582  4. Let d = 4 éb/4ù + 4 583  5. Let P = [1]1 || [2]1 || [1]1 || [radix]3 || [10]1  || [u mod 256]1 || [n]4 || [t]4. 584  6 When B is encoded as a byte string in Step 6i, b is the number of bytes in the encoding. The definition of d ensures  that the output of the Feistel round function is at least four bytes longer than this encoding of B, which minimizes any  bias in the modular reduction in Step 6vi.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  15  6. For i from 9 to 0: 585  i. Let Q = T || [0](−t−b−1) mod 16 || [i]1 || [NUMradix (A)]b. 586  ii. Let R = PRF(P || Q). 587  iii. Let S be the string of the first d bytes of the following string of éd/16ù blocks: 588  R || CIPHK (R Å [1]16) || CIPHK (R Å [2]16) … CIPHK (R Å [éd/16ù – 1]16). 589  iv. Let y = NUM(S). 590  v. If i is even, let m = u; else, let m = v.  591  vi. Let c = (NUMradix (B) – y) mod radix m. 592  vii. Let C = STRm  radix (c). 593  viii.  Let B = A. 594  ix. Let A = C. 595  7. Return A || B.  596  597  Description: 598  The FF1.Decrypt algorithm is similar to the FF1.Encrypt algorithm; the differences are in Step 6, 599  where: 1) the order of the indices is reversed, 2) the roles of A and B are swapped, and 3) modular 600  addition is replaced by modular subtraction, in Step 6vi.  601  5.2 FF3-1 602  The specifications for the FF3-1.Encrypt and FF3-1.Decrypt functions are given in Algorithms 9 603  and 10 below. The parameters radix, minlen, and maxlen in FF3-1.Encrypt and FF3-1.Decrypt 604  shall meet the following requirements: 605  606  • radix ∈ [2 .. 216],  607  • radix  minlen ≥ 1 000 000, and  608  • 2 ≤ minlen ≤ maxlen ≤ 2 ëlog radix (296)û. 609  610  Algorithm 9: FF3-1.Encrypt(K, T, X)  611  612  Prerequisites: 613  Designated cipher function, CIPH, of an approved 128-bit block cipher; 614  Key, K, for the block cipher;  615  Base, radix; 616  Range of supported message lengths, [minlen .. maxlen]. 617  618  Inputs: 619  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 620  Tweak bit string, T, such that LEN(T) = 56. 621  622  623  Output: 624  Numeral string, Y, such that LEN(Y) = n. 625  626  Steps: 627  1. Let u = ⌈ n/2⌉; v = n – u. 628  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 629  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  16  3. Let TL = T [0 .. 27] || 04 and TR = T [32 .. 55] || T [28 .. 31] || 04. 630  4. For i from 0 to 7: 631  i. If i is even, let m = u and W = TR, else let m = v and W = TL. 632  ii. Let P = W ⊕ [i]4 || [NUMradix (REV(B))]12. 633  iii Let S = REVB(CIPHREVB(K) REVB(P)). 634  iv. Let y = NUM(S).  635  v. Let c = (NUMradix (REV(A)) + y) mod radix m.  636  vi.  Let C = REV(STRm  radix (c)). 637  vii.  Let A = B. 638  viii. Let B = C. 639  5. Return A || B.  640  641  Description: 642  The “split” of the numeral string X into two substrings, A and B, is performed in Steps 1 and 2. If 643  n is even, LEN(A)=LEN(B); otherwise, LEN(A)=LEN(B)+1.7 The tweak, T, is partitioned in Step 3 644  into a 32-bit left tweak, TL, and a 32-bit right tweak, TR. An iteration loop for the eight Feistel 645  rounds of FF3-1 is initiated in Step 4, executing eight substeps for each round, as follows: 646  647  In Step 4i, the parity of the round number, i, determines the length, m, of the substring A, and 648  whether TL or TR will be used as W in Step 4ii, in which a 32-bit encoding of i, XORed with W, is 649  concatenated with a 96-bit encoding of B to produce a block, P. In Step 4iii, the block cipher under 650  the key, is applied to P using the byte-reversed ordering convention, to produce a block, S. (In 651  Figure 1, S corresponds to the output of FK.) In Steps 4iv to 4vi, S is combined with the substring 652  A to produce a numeral string C in the same base and with the same length. (In Figure 1, the 653  combining of S with A is indicated by the “+” operation, although this operation is different than 654  for FF1 in that FF3-1 uses the opposite ordering convention for the conversion of strings to 655  numbers and vice versa.) In particular, in Step 4iv, S is converted to a number, y. In Step 4v, the 656  number y is added to the number represented by the substring A, and the result is reduced modulo 657  the mth power of radix, yielding a number, c, which is converted to a numeral string in Step 4vi. 658  In Steps 4vii and 4viii, the roles of A and B are swapped for the next round: the substring B is 659  renamed as the substring A, and the modified A (i.e., C) is renamed as B.  660  661  This completes one round of the Feistel structure in FF3-1. After the eighth round, the 662  concatenation of A and B is returned as the output in Step 5. 663  664  Algorithm 10: FF3-1.Decrypt(K, T, X)  665  666  Prerequisites: 667  Designated cipher function, CIPH, of an approved 128-bit block cipher; 668  Key, K, for the block cipher;  669  Base, radix; 670  Range of supported message lengths, [minlen .. maxlen]. 671  672  Inputs: 673  Numeral string, X, in base radix of length n, such that n ∈ [minlen .. maxlen]; 674  7 If n is odd, A is one numeral longer than B, in contrast to FF1, where B is one numeral longer than A.  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  17  Tweak bit string, T, such that LEN(T ) = 64. 675  676  Output: 677  Numeral string, Y, such that LEN(Y ) = n. 678  679  Steps: 680  1. Let u = ⌈n /2⌉; v = n – u. 681  2.  Let A = X [1 .. u]; B = X [u + 1 .. n]. 682  3. Let TL = T [0 .. 27] || 04 and TR = T [32 .. 55] || T [28 .. 31] || 04. 683  4. For i from 7 to 0: 684  i. If i is even, let m = u and W = TR, else let m = v and W =TL. 685  ii. P = W ⊕ [i]4 || [NUMradix (REV(A))]12.  686  iii Let S = REVB(CIPHREVB(K) REVB(P)). 687  iv. Let y = NUM(S).  688  v. Let c = (NUMradix (REV(B)) – y) mod radix m.  689  vi.  Let C = REV(STRm  radix (c)). 690  vii.  Let B = A. 691  viii. Let A = C. 692  5. Return A || B. 693  694  Description: 695  The FF3-1.Decrypt algorithm is similar to the FF3-1.Encrypt algorithm; the differences are in Step 696  4, where: 1) the order of the indices is reversed, 2) the roles of A and B are swapped, and  697  3) modular addition is replaced by modular subtraction, in Step 4v.  698  6 Conformance 699  Implementations of FF1.Encrypt, FF1.Decrypt, FF3-1.Encrypt, or FF3-1.Decrypt may be tested 700  for conformance to this Recommendation under the auspices of NIST’s Cryptographic Algorithm 701  Validation Program [12].  702  Component functions such as PRF are not approved for use independent of these four functions. 703  In order to claim conformance with this Recommendation, an implementation of FF1 or FF3-1 704  may support as few as one value for the base.  705  Two implementations can only interoperate when they support common values for the base. 706  Moreover, FF1 and FF3-1 have two parameters, minlen and maxlen, that determine the lengths for 707  the numeral strings that are supported by an implementation of the encryption or decryption 708  function for the mode. FF1 also has a parameter, maxTlen, that indicates the maximum supported 709  length of a tweak string. The selection of these parameters may also affect interoperability.  710  For every algorithm that is specified in this Recommendation, a conforming implementation may 711  replace the given set of steps with any mathematically equivalent set of steps. In other words, 712  different procedures that produce the correct output for any input are permitted. 713  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  18  Appendix A: Parameter Choices and Security 714  The values of the parameters, e.g., radix, minlen, and maxlen affect the security that FF1 and FF3-1 715  can offer, because, as for any FPE method, encrypted data may be vulnerable to guessing attacks 716  when the number of possible inputs is sufficiently small.  717  In particular, for a base radix numeral string S, there are radix LEN(S) possible values. For any 718  ciphertext C, the corresponding plaintext has the same length; therefore, an attacker can guess the 719  plaintext with probability 1/radix LEN(C) by selecting a numeral string of LEN(C) at random. 720  Repeated guesses increase the attacker’s probability of success proportionately: with g distinct 721  guesses, the probability is g/ radix LEN(C). 722  For example, SSNs are base 10 numeral strings of length 9, so there are one billion possibilities. 723  If an attacker could guess a thousand different values for an SSN, one of the guesses would be 724  correct with probability 1000/109, i.e., one in a million.  725  The original specifications of FF1and FF3 only imposed a modest absolute minimum of 100 on 726  the number of possible inputs in order to preclude a generic meet-in-the-middle attack on the 727  Feistel structure [17]. However, in order to mitigate guessing attacks and the analytic attacks 728  described in [1] and [8], the number of possible inputs, namely radix minlen, is required to be greater 729  than or equal to 1 000 000, for both FF1 and FF3-1. In order to further limit the effectiveness of 730  guessing attacks, implementations should also limit the number of guesses that an attacker can 731  mount, if possible. 732  In order to prevent attacks against one instance of encryption from applying to other instances, 733  implementations should enforce the use of different tweaks for different instances, as discussed in 734  Appendix C. Usually, tweaks are non-secret information that can be associated with instances of 735  encryption. For FF3-1, the tweak length is fixed, but for FF1 the maximum tweak length parameter, 736  maxTlen, should be chosen to accommodate the desired tweaks for the implementation.  737  Two other potential parameters of the Feistel structure are fixed for FF1 and FF3-1, namely, the 738  number of Feistel rounds and the imbalance, i.e., the values of the lengths u and v in Figure 1. Both 739  of these parameters were set with consideration to both performance and security requirements. 740  See Appendix H of [2] for a discussion.  741  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  19  Appendix B: Security Goal 742  The designers of FFX aimed to achieve strong-pseudorandom permutation (PRP) security for a 743  conventional block cipher [10]. In the FFX proposal to NIST [2], the designers of FFX cited the 744  history of cryptographic results concerning Feistel networks as underlying their selection of the 745  FFX mechanism. They asserted that, under the assumption that the underlying round function is 746  a good pseudorandom function (PRF), contemporary cryptographic results and experience 747  indicate that FFX achieved several cryptographic goals, including nonadaptive message-recovery 748  security, chosen-plaintext security, and even PRP-security against an adaptive chosen-ciphertext 749  attack. The quantitative security would depend on the number of rounds used, the imbalance, and 750  the adversary's access to plaintext-ciphertext pairs. See [2] for details.  751  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  20  Appendix C: Tweaks 752  Tweaks have been supported in stand-alone block ciphers, such as Schroeppel’s Hasty Pudding 753  [18], and the notion was later formalized and investigated by Liskov, Rivest, and Wagner [9]. 754  Tweaks are important for FPE modes, because FPE may be used in settings where the number of 755  possible character strings is relatively small. In such settings, the tweak should vary with each 756  instance of the encryption whenever possible. 757  For example, suppose that in an application for CCNs, the leading six digits and the trailing four 758  digits need to be available to the application, so that only the remaining six digits in the middle of 759  the CCNs are encrypted. There are a million different possibilities for these middle-six digits, so, 760  in a database of 100 million CCNs, about a hundred distinct CCNs would be expected to share 761  each possible value for these six digits. If the hundred CCNs that shared a given value for the 762  middle-six digits were encrypted with the same tweak, then their ciphertexts would be the same. 763  If, however, the other ten digits had been the tweak for the encryption of the middle-six digits, 764  then the hundred ciphertexts would almost certainly be different. 765  Similarly, in the encrypted database, about a hundred CCNs would be expected to share each 766  possible value for the ciphertext, i.e., the middle-six digits. If the hundred CCNs that produce a 767  given ciphertext had been encrypted with the same tweak, then the corresponding plaintexts would 768  also be the same. This outcome would be undesirable because the compromise of the 769  confidentiality of any of the hundred CCNs would reveal the others. 770  If, however, the leading six digits and the trailing four digits of the CCN had been used as the 771  tweak, then the corresponding plaintexts would almost certainly be different. Therefore, for 772  example, learning that the decryption of 111111-770611-1111 is 111111-123456-1111 would not 773  reveal any information about the decryption of 999999-770611-9999, because the tweak in that 774  case was different. 775  In general, if there is information that is available and statically associated with a plaintext, it is 776  recommended to use that information as a tweak for the plaintext. Ideally, the non-secret tweak 777  associated with a plaintext is associated only with that plaintext. 778  Extensive tweaking means that fewer plaintexts are encrypted under any given tweak. This 779  corresponds, in the security model that is described in [2], to fewer queries to the target instance 780  of the encryption.  781  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  21  Appendix D: Examples 782  Examples for FF1 and FF3-1 are available at the examples page on NIST’s Computer Security 783  Resource Center website: https://csrc.nist.gov/projects/cryptographic-standards-and-784  guidelines/example-values.  785  NIST SP 800-38G REV. 1 (DRAFT) BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  22  Appendix E: References 786  [1] M. Bellare, V. T. Hoang, and S. Tessaro, “Message-recovery attacks on Feistel-based787  Format Preserving Encryption,” in ACM CCS ’16, pages 444–455, ACM Press, 2016, 788  https://doi.org/10.1145/2976749.2978390.  789  [2] M. Bellare, P. Rogaway, and T. Spies, The FFX Mode of Operation for Format-790  Preserving Encryption, Draft 1.1, February 20, 2010, 791  https://csrc.nist.gov/csrc/media/projects/block-cipher-792  techniques/documents/bcm/proposed-modes/ffx/ffx-spec.pdf. 793  [3] M. Bellare, P. Rogaway, and T. Spies, Addendum to “The FFX Mode of Operation for794  Format-Preserving Encryption”: A parameter collection for enciphering strings of 795  arbitrary radix and length, Draft 1.0, September 3, 2010, 796  https://csrc.nist.gov/csrc/media/projects/block-cipher-797  techniques/documents/bcm/proposed-modes/ffx/ffx-spec2.pdf.  798  [4] E. Brier, T. Peyrin, and J. Stern, BPS: a Format-Preserving Encryption Proposal,799  [April 2010], https://csrc.nist.gov/csrc/media/projects/block-cipher-800  techniques/documents/bcm/proposed-modes/bps/bps-spec.pdf.  801  [5] Y-A. de Montjoye, L. Radaelli, V. Kumar Singh, and A. Pentland, “Unique in the802  shopping mall: On the reidentifiability of credit card metadata,” Science, vol. 347 no. 803  6221 (January 30, 2016), pp. 536-539, https://doi.org/10.1126/science.1256297.  804  [6] M. Dworkin and R. Perlner, Analysis of VAES3 (FF2), Report no. 2015/306, IACR805  Cryptology ePrint Archive, April 2, 2015, https://eprint.iacr.org/2015/306 806  [7] F. B. Durak and S. Vaudenay, “Breaking the FF3 Format-Preserving Encryption Standard807  Over Small Domains” in Advances in Cryptology—CRYPTO 2017, Lecture Notes in 808  Computer Science vol. 10402, Springer, pp. 679–707, https://doi.org/10.1007/978-3-319-809  63715-0_23.  810  [8] V.T. Hoang, S. Tessaro, N. Trieu, “The Curse of Small Domains: New Attacks on811  812  813  Format-Preserving Encryption” in Advances in Cryptology—CRYPTO 2018, Lecture  Notes in Computer Science 10991, Springer, Cham., pp. 221–251,  https://doi.org/10.1007/978-3-319-96884-1_8.  814  [9] M. Liskov, R. Rivest, and D. Wagner, “Tweakable block ciphers,” in Advances in815  Cryptology—CRYPTO 2002, Lecture Notes in Computer Science 2442, Berlin: Springer, 816  pp. 31–46, September 13, 2002, https://doi.org/10.1007/3-540-45708-9_3. 817  [10] M. Luby and C. Rackoff, “How to construct pseudorandom permutations from818  pseudorandom functions,” SIAM Journal on Computing, vol. 17 no. 2 (1988), pp. 373–819  386, https://doi.org/10.1137/0217022. 820  [11] National Institute of Standards and Technology, Explanation of changes to Draft SP 800-821  38G, June 27, 2014, https://csrc.nist.gov/news/2014/explanation-of-changes-to-draft-sp-822  800-38G.823  [12] National Institute of Standards and Technology, Cryptographic Algorithm Validation824  Program (CAVP), https://csrc.nist.gov/projects/cryptographic-algorithm-validation-825  program. 826  https://doi.org/10.1007/978-3-319-96884-1_8  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  23  [13] National Institute of Standards and Technology, Federal Information Processing Standard 827  (FIPS) 197, The Advanced Encryption Standard (AES), November 2001, 828  https://doi.org/10.6028/NIST.FIPS.197.  829  [14] National Institute of Standards and Technology. NIST Special Publication (SP) 800-38A, 830  Recommendation for Block Cipher Modes of Operation—Methods and Techniques, 831  December 2001, https://doi.org/10.6028/NIST.SP.800-38A.  832  [15] National Institute of Standards and Technology. NIST Special Publication (SP) 800-67 833  Revision 2, Recommendation for the Triple Data Encryption Algorithm (TDEA) Block 834  Cipher, January 2012, https://doi.org/10.6028/NIST.SP.800-67r2.  835  [16] National Institute of Standards and Technology. NIST Special Publication (SP) 800-133, 836  Recommendation for Cryptographic Key Generation, December 2012, 837  https://doi.org/10.6028/NIST.SP.800-133.  838  [17] J. Patarin, Generic attacks on Feistel schemes, Report no. 2008/036, IACR Cryptology 839  ePrint Archive, January 24, 2008, https://eprint.iacr.org/2008/036. 840  [18] R. Schroeppel, Hasty Pudding Cipher specification [Web page], June 1998 (revised May 841  1999), http://richard.schroeppel.name:8015/hpc/hpc-spec.  842  NIST SP 800-38G REV. 1 (DRAFT)  BLOCK CIPHER MODES OF OPERATION:  METHODS FOR FORMAT-PRESERVING ENCRYPTION  24  Appendix F: Revision History 843  A third mode, FF2—submitted to NIST under the name VAES3—was included in the initial draft 844  of this publication. As part of the public review of Draft NIST Special Publication (SP) 800-38G 845  and as part of its routine consultation with other agencies, NIST was advised by the National 846  Security Agency in general terms that the FF2 mode in the draft did not provide the expected 128 847  bits of security strength. NIST cryptographers confirmed this assessment via the security analysis 848  in [6] and announced the removal of FF2 in [11].  849  For both FF1 and FF3-1, the domain size, i.e., the number of possible input strings, is the quantity 850  radix  minlen. In response to the analysis in [8], the lower bound that is required for the domain size  851  in the specifications of both FF1 in Sec. 5.1 and FF3-1 in Sec. 5.2 was raised from one hundred in 852  the original publication to one million in Rev. 1. 853  854  The name “FF1” is unchanged from the original version of this publication, because the lower 855  bound on the domain size only affects which parameter combinations are approved, not the 856  specification of the encryption and decryption functions. FF3-1 has a different name than FF3 857  because, in addition to the new lower bound on the domain size, the encryption and decryption 858  functions of FF3 were revised.  859  860  In particular, in response to the analysis in [7] on FF3, the size of the tweak specified in Sec. 5.2 861  was reduced from 64 bits for FF3 to 56 bits for FF3-1, which entailed the modification of the 862  definitions of the strings TL and TR in Step 3 of Algorithm 9 and Step 3 of Algorithm 10.  The 863  modified definitions of these two strings can equivalently be implemented by taking a 64-bit 864  tweak, reordering some of its bits in a particular manner, and then forcing the bits in eight particular 865  bit positions to be zero. For tweaks with certain properties—for example, if non-zero bits only 866  occur in the leading 28 bit positions—the specification of FF3-1 is backwards compatible with the 867  original specification of FF3. 868",
    "abstract": ""
}